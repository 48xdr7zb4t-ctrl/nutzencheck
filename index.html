<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Nutzen-Check – Grundgerüst</title>
  <style>
/* ===========================
   0) Design Tokens / Globals
=========================== */
:root{
  --bg:#0b0f17;
  --panel:#121a2a;
  --panel2:#0f1625;
  --text:#e8eefc;
  --muted:#9fb0d0;
  --line:rgba(255,255,255,.10);
  --accent:#6aa6ff;

  --good:#2ecc71;
  --warn:#f1c40f;
  --bad:#e74c3c;
  --darkbad:#7f1d1d;

  --shadow: 0 12px 40px rgba(0,0,0,.45);
  --r:16px;
  --r2:22px;

  --overlayZ:1001;
  --backdropZ:1000;

  --maxw:1200px;
}

/* ===========================
   1) Base / Layout
=========================== */
*{ box-sizing:border-box; }
html,body{ height:100%; }

body{
  margin:0;
  font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
  color:var(--text);
  background:
    radial-gradient(1200px 800px at 20% 10%, rgba(106,166,255,.22), transparent 60%),
    radial-gradient(900px 700px at 90% 30%, rgba(46,204,113,.18), transparent 55%),
    var(--bg);
}

a{ color:inherit; }

.wrap{
  max-width:var(--maxw);
  margin:0 auto;
  padding:20px;
}

/* ===========================
   2) Header / Navigation
=========================== */
header{
  display:flex;
  gap:12px;
  align-items:center;
  justify-content:space-between;
  padding:14px 16px;
  border:1px solid var(--line);
  border-radius:var(--r2);
  background:linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
  box-shadow:var(--shadow);
}

.brand{ display:flex; gap:12px; align-items:center; }
.logo{
  width:40px;height:40px;border-radius:14px;
  background:linear-gradient(135deg, rgba(106,166,255,.9), rgba(46,204,113,.75));
  box-shadow:0 10px 30px rgba(106,166,255,.18);
}
.brand h1{ font-size:16px; margin:0; }
.brand p{ margin:0; font-size:12px; color:var(--muted); }

.nav{
  display:flex;
  gap:10px;
  flex-wrap:wrap;
  justify-content:flex-end;
}

/* ===========================
   3) Buttons / Inputs
=========================== */
.btn{
  appearance:none;
  border:1px solid var(--line);
  background:rgba(255,255,255,.03);
  color:var(--text);
  padding:10px 12px;
  border-radius:14px;
  cursor:pointer;
  transition:.15s transform,.15s background,.15s border-color;
  font-weight:600;
  font-size:13px;
}
.btn:hover{
  transform:translateY(-1px);
  background:rgba(255,255,255,.05);
  border-color:rgba(255,255,255,.18);
}
.btn.primary{
  border-color:rgba(106,166,255,.35);
  background:rgba(106,166,255,.10);
}

label{
  font-size:12px;
  color:var(--muted);
  display:block;
  margin-bottom:6px;
}

select, input{
  width:100%;
  padding:10px 12px;
  border-radius:14px;
  border:1px solid var(--line);
  background:rgba(0,0,0,.18);
  color:var(--text);
  outline:none;
}

/* ===========================
   4) Grid / Cards / Utilities
=========================== */
.grid{
  display:grid;
  grid-template-columns:1.4fr .9fr;
  gap:14px;
  margin-top:14px;
}

.card{
  border:1px solid var(--line);
  border-radius:var(--r2);
  background:linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
  box-shadow:var(--shadow);
  overflow:hidden;
}
.card h2{
  margin:0;
  padding:14px 16px;
  font-size:14px;
  letter-spacing:.2px;
  border-bottom:1px solid var(--line);
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
  background:rgba(0,0,0,.08);
}
.card .body{ padding:14px 16px; }

.row{
  display:flex;
  gap:10px;
  flex-wrap:wrap;
  align-items:center;
}

.field{ flex:1; min-width:200px; }

.split{
  display:grid;
  grid-template-columns:1fr 1fr;
  gap:12px;
}

.muted{ color:var(--muted); }

@media (max-width:980px){
  .grid{ grid-template-columns:1fr; }
  .nav{ justify-content:flex-start; }
  .split{ grid-template-columns:1fr; }
}


/* ===========================
   5) Chips / Dots
=========================== */
.chip{
  display:inline-flex;
  align-items:center;
  gap:8px;
  padding:8px 10px;
  border:1px solid var(--line);
  border-radius:999px;
  background:rgba(0,0,0,.16);
  font-size:12px;
  color:var(--muted);
}

.dot{
  width:10px;height:10px;border-radius:999px;
  background:var(--accent);
}
.dot.good{ background:var(--good); }
.dot.warn{ background:var(--warn); }
.dot.bad{ background:var(--bad); }
.dot.darkbad{ background:var(--darkbad); }


/* ===========================
   6) Table
=========================== */
.tableWrap{
  overflow:auto;
  border-radius:16px;
  border:1px solid var(--line);
  background:rgba(0,0,0,.18);
}
table{ width:100%; border-collapse:collapse; min-width:900px; }
th,td{
  padding:10px;
  border-bottom:1px solid var(--line);
  font-size:12px;
  vertical-align:top;
}
th{
  position:sticky;
  top:0;
  z-index:2;
  text-align:left;
  background:rgba(15,22,37,.95);
}
td{ color:rgba(232,238,252,.92); }
tr:hover td{ background:rgba(255,255,255,.03); }

/* ===========================
   7) Pages
=========================== */
.page{ display:none; }
.page.isActive{ display:block; }

/* ===========================
   8) Role/Stress “Why” Blocks
=========================== */
#nutzenRoleWhyBase{
  max-height:520px;
  overflow:auto;
  padding-right:6px;
}

.whyRoleBlock{
  border:1px solid var(--line);
  border-radius:16px;
  padding:12px;
  margin-bottom:10px;
  background:rgba(0,0,0,.10);
}

.whyRoleHead{
  display:flex;
  align-items:flex-start;
  justify-content:space-between;
  gap:10px;
  margin-bottom:10px;
}

.whyRoleTitle{ font-weight:700; font-size:13px; }

.whyRoleMeta{
  font-size:12px;
  color:var(--muted);
  white-space:nowrap;
}

.whyCols{
  display:grid;
  grid-template-columns:1fr 1fr;
  gap:12px;
}

.whyColTitle{
  font-size:12px;
  color:var(--muted);
  margin-bottom:6px;
}

.whyLine{
  font-size:12.5px;
  line-height:1.55;
  margin:2px 0;
}

@media (max-width:980px){
  .whyCols{ grid-template-columns:1fr; }
}

/* ===========================
   8b) Stress Legend Hover Blocks
=========================== */

#stressLegendAll{
  max-height:520px;
  overflow:auto;
  padding-right:6px;
}

.whyStressBlock{
  border:1px solid var(--line);
  border-radius:16px;
  padding:12px;
  margin-bottom:10px;
  background:rgba(0,0,0,.10);
}

.whyStressHead{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
  cursor:default;
}

.whyStressTitle{
  display:flex;
  align-items:center;
  gap:10px;
  font-weight:700;
  font-size:13px;
}

.whyStressHint{
  font-size:12px;
  color:var(--muted);
  white-space:nowrap;
}

.whyStressBody{
  display:none;
  margin-top:10px;
  padding-top:10px;
  border-top:1px solid var(--line);
}

/* Hover klappt nach unten auf */
.whyStressBlock:hover .whyStressBody{
  display:block;
}

/* optional: kleine “Hover to expand” Optik */
.whyStressBlock:hover{
  background:rgba(0,0,0,.14);
  border-color:rgba(255,255,255,.18);
}

/* ===========================
   8c) Stress Why-Now (hover details)
=========================== */

#stressWhyNow{
  max-height:520px;
  overflow:auto;
  padding-right:6px;
}

.whyNowBlock{
  border:1px solid var(--line);
  border-radius:16px;
  padding:12px;
  margin-bottom:10px;
  background:rgba(0,0,0,.10);
}

.whyNowHead{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
}

.whyNowLeft{
  display:flex;
  align-items:center;
  gap:10px;
  min-width:0;
}

.whyNowTitle{
  font-weight:700;
  font-size:13px;
  white-space:nowrap;
}

.whyNowMeta{
  font-size:12px;
  color:var(--muted);
  white-space:nowrap;
}

.whyNowBody{
  display:none;
  margin-top:10px;
  padding-top:10px;
  border-top:1px solid var(--line);
}

.whyNowBlock:hover .whyNowBody{ display:block; }

.whyNowBlock:hover{
  background:rgba(0,0,0,.14);
  border-color:rgba(255,255,255,.18);
}

.trigLine{
  font-size:12.5px;
  line-height:1.55;
  margin:2px 0;
}

/* ===========================
   9) Overlay (clean + single source of truth)
   - Entfernt doppelte Regeln & !important-Spam
   - Backdrop + Overlay per .isOpen sichtbar
=========================== */
.backdrop{
  position:fixed;
  inset:0;
  background:rgba(0,0,0,.6);
  display:none;
  z-index:var(--backdropZ);
}
.backdrop.isOpen{ display:block; }

.overlay{
  position:fixed;
  left:50%;
  top:50%;
  transform:translate(-50%,-50%);

  width:min(980px, calc(100% - 24px));
  max-height:calc(100vh - 48px);
  overflow:auto;

  background:linear-gradient(180deg, rgba(18,26,42,.96), rgba(15,22,37,.98));
  border:1px solid rgba(255,255,255,.12);
  border-radius:var(--r2);
  box-shadow:var(--shadow);
  padding:14px;

  display:none;
  z-index:var(--overlayZ);
}
.overlay.isOpen{ display:block; }

.overlayTop{
  position:sticky;
  top:0;
  z-index:2;
  display:flex;
  gap:10px;
  align-items:center;
  justify-content:space-between;
  padding:4px 6px 10px;
  border-bottom:1px solid var(--line);
  background:linear-gradient(180deg, rgba(18,26,42,.98), rgba(15,22,37,.92));
  backdrop-filter:blur(6px);
}
.overlayTop strong{ font-size:13px; }

.overlayGrid{
  display:grid;
  grid-template-columns:1.2fr .8fr;
  gap:12px;
  padding-top:12px;
}

.overlaySpan2{ grid-column:1 / -1; }

@media (max-width:980px){
  .overlayGrid{ grid-template-columns:1fr; }
  .overlaySpan2{ grid-column:1 / 2; }
}

main.grid{
  display:grid;
  grid-template-columns: 1.25fr 0.75fr; /* links content, rechts sidebar */
  gap: 14px;
  align-items:start;
}

@media (max-width: 980px){
  main.grid{ grid-template-columns: 1fr; }
}
  </style>
</head>

<body>
  <div class="wrap">

    <header>
      <div class="brand">
        <div class="logo" aria-hidden="true"></div>
        <div>
          <h1>Nutzen-Check</h1>
          <p class="muted">Grundgerüst: Header-Sets · Rollen · Stress-Flag · Buy-Bands · Erklärungen</p>
        </div>
      </div>

      <nav class="nav" aria-label="Seiten Navigation">
        <button class="btn" onclick="goPage('home')">Home</button>
        <button class="btn" onclick="goPage('table')">Tabelle</button>
        <button class="btn" onclick="goPage('roles')">Rollen</button>
        <button class="btn" onclick="goPage('stress')">Stress</button>
        <button class="btn primary" onclick="openNutzenOverlay()">Nutzen Overlay</button>
      </nav>
    </header>

    <!-- ===== PAGES ===== -->
    <main class="grid">

      <!-- LEFT: Main content -->
        <section class="card">
  <div id="page-home" class="page isActive">
          <h2>
            <span>Home</span>
          </h2>
          <div class="body">
            <div class="split">
  <!-- LEFT: Quick Controls -->
  <div class="card" style="box-shadow:none">
    <h2>Quick Controls</h2>
    <div class="body">

      <div class="row">
        <div class="field">
          <label for="nutzenHeaderSet">Header-Set</label>
          <select id="nutzenHeaderSet">
            <option value="standard">Standard</option>
            <option value="banks">Banks</option>
            <option value="reits">REITs</option>
            <option value="utilities">Utilities</option>
            <option value="brokers">Brokers / Asset Manager</option>
            <option value="insurance">Insurance</option>
            <option value="commodities">Commodities</option>
          </select>
        </div>

        <div class="field">
          <label for="nutzenCagrYear">CAGR Jahr</label>
          <select id="nutzenCagrYear">
            <option value="1">1Y</option>
            <option value="2">2Y</option>
            <option value="3">3Y</option>
            <option value="4" selected>4Y</option>
          </select>
        </div>

        <div class="field">
          <label for="nutzenVolYear">Vol Jahr</label>
          <select id="nutzenVolYear">
            <option value="1" selected>1Y</option>
            <option value="5">5Y</option>
            <option value="10">10Y</option>
          </select>
        </div>
      </div>

      <div class="row" style="margin-top:10px">
        <button class="btn" id="nutzenBtnRecalc">Recalc</button>
        <button class="btn" id="nutzenBtnExport">Export</button>
        <button class="btn" onclick="goPage('table')">Zur Tabelle</button>
      </div>

    </div>
  </div>

  <!-- RIGHT: DCF Einstellungen -->
  <div class="card" style="box-shadow:none">
    <h2>DCF Einstellungen</h2>
    <div class="body">

      <div class="row">
        <div class="field" style="flex:1">
          <label for="ovDcfPreset">Preset</label>
<select id="ovDcfPreset">
  <option value="eu">EU</option>
  <option value="usa">USA</option>
  <option value="middleeast">Middle East</option>
  <option value="china">China</option>
  <option value="defensive">Defensiv</option>
  <option value="normal">Normal</option>
  <option value="aggressive">Aggressiv</option>
  <option value="custom">Custom</option>
</select>
        </div>
      </div>

      <div class="row">
        <div class="field">
          <label for="ovRf">rf (Risk-free) %</label>
          <input id="ovRf" type="text" value="3,00"/>
        </div>
        <div class="field">
          <label for="ovErp">ERP %</label>
          <input id="ovErp" type="text" value="5,00"/>
        </div>
      </div>

      <div class="row">
        <div class="field">
          <label for="ovGt">gT (Terminal) %</label>
          <input id="ovGt" type="text" value="2,50"/>
        </div>
        <div class="field">
          <label for="ovYears">Years</label>
          <input id="ovYears" type="number" min="1" max="30" step="1" value="5"/>
        </div>
      </div>

    </div>
  </div>
</div>
  </div>
 </div>

            
     

   


        <div style="margin-top:14px">
  <div class="muted" style="font-size:12px;margin-bottom:6px">Excel Paste (Copy → Paste)</div>
  <textarea id="excelPaste"
    placeholder="Excel markieren → Cmd+C → hier einfügen (Tab-getrennt)"
    style="width:100%;min-height:140px;padding:12px;border-radius:16px;border:1px solid var(--line);background:rgba(0,0,0,.20);color:var(--text);outline:none;resize:vertical"></textarea>

  <div class="row" style="margin-top:10px">
    <button class="btn primary" id="btnParseExcel" style="flex:1">In Tabelle übernehmen</button>
    <button class="btn" id="btnClearExcel">Leeren</button>
  </div>

  <p class="muted" style="margin:10px 0 0 0;font-size:12px;line-height:1.4">
    Unterstützt 2 Formate:<br>
    (A) 2 Spalten: <span class="muted">Header | Wert</span><br>
    (B) 2 Zeilen: <span class="muted">Header-Zeile</span> + <span class="muted">Wert-Zeile</span>
  </p>
</div>



        <div id="page-table" class="page">
          <h2>
            <span>Tabelle</span>
            <span class="chip"><span class="dot"></span> Header-Reihenfolge egal (Mapping über Namen)</span>
          </h2>
          <div class="body">


            <div class="row" style="margin-bottom:12px">
  <div class="field" style="min-width:220px">
    <label for="nutzenHeaderSetTable">Header-Set</label>
    <select id="nutzenHeaderSetTable"></select>
  </div>
  <div class="field" style="min-width:160px">
    <label for="nutzenCagrYearTable">CAGR Jahr</label>
    <select id="nutzenCagrYearTable"></select>
  </div>
  <div class="field" style="min-width:160px">
    <label for="nutzenVolYearTable">Vol Jahr</label>
    <select id="nutzenVolYearTable"></select>
  </div>
</div>

            <div class="tableWrap" aria-label="Nutzen Tabelle">
              <table id="nutzenTable">
                <thead>
                  <tr id="nutzenTableHeadRow">
                    <!-- JS füllt THs passend zum Header-Set -->
                    <th>Header</th>
                    <th>Wert</th>
                    <th class="muted">Notizen</th>
                  </tr>
                </thead>
                <tbody id="nutzenTableBody">
                </tbody>
              </table>
            </div>

            <div class="row" style="margin-top:12px">
              <span class="chip"><span class="dot"></span> Visible-Indices: CAGR/Vol Filter</span>
              <span class="chip"><span class="dot"></span> Missing-Handling: “– / n/a”</span>
            </div>
          </div>
        </div>

        <div id="page-roles" class="page">
          <h2>
            <span>Rollen</span>
            <span class="chip"><span class="dot"></span> Base + Health</span>
          </h2>
          <div class="body">
            <div class="split">
              <div class="card" style="box-shadow:none">
                <h2>Aktive Rollen</h2>
                <div class="body">
                  <ul id="nutzenRolesActive" style="margin:0;padding-left:18px;line-height:1.6">
                    <li>–</li>
                  </ul>
                </div>
              </div>

              <div class="card" style="box-shadow:none">
                <h2>Rollen Erklärungen</h2>
                <div class="body">
                  <div class="muted" style="font-size:12px;margin-bottom:6px">Base</div>
                  <div id="nutzenRoleWhyBase">–</div>
                  <div class="muted" style="font-size:12px;margin:12px 0 6px">Health</div>
                  <div id="nutzenRoleWhyHealth">–</div>
                </div>
              </div>
            </div>
          </div>
        </div>

<div id="page-stress" class="page">

  <div class="body">
    <div class="split">

      <!-- Card 1: aktueller Stress + Warum -->
      <div class="card" style="box-shadow:none">
        <h2>Aktueller Stress</h2>
        <div class="body">

          <div class="row" style="gap:8px">
            <span class="chip">
              <span class="dot" id="stressPageDot"></span>
              <span id="stressPageLabel">Stress: –</span>
            </span>
          </div>

          <div class="muted" style="font-size:12px;margin:12px 0 6px">Warum diese Farbe?</div>
          <div id="stressWhyNow">–</div>

        </div>
      </div>

      <!-- Card 2: Farben-Erklärung (immer alle Farben + Base/Health) -->
      <div class="card" style="box-shadow:none">
        <h2>Farben Erklärung</h2>
        <div class="body">
          <div id="stressLegendAll">–</div>
        </div>
      </div>

    </div>
  </div>
</div>

      </section>

      <!-- RIGHT: Side panel -->
      <aside class="card">
        <h2>
          <span>Inputs & Status</span>
          <span class="chip"><span class="dot"></span> IDs ready</span>
        </h2>
        <div class="body">
          <div class="row">
            <div class="field">
              <label for="nutzenTicker">Ticker / Company</label>
              <input id="nutzenTicker" placeholder="z.B. KO / AAPL / MSFT" />
            </div>
          </div>

          <div class="row" style="margin-top:10px">
            <div class="field">
              <label for="nutzenFairValue">Fair Value</label>
              <input id="nutzenFairValue" placeholder="z.B. 120.50" />
            </div>
          </div>

          <div class="row" style="margin-top:10px">
            <span class="chip"><span class="dot"></span> Overlay: Erklärungen</span>
            <span class="chip"><span class="dot"></span> Table: Mapping</span>
          </div>

          <div style="margin-top:14px">
            <button class="btn primary" style="width:100%" onclick="openNutzenOverlay()">Overlay öffnen</button>
          </div>

          <div style="margin-top:12px">
            <div class="muted" style="font-size:12px;margin-bottom:6px">Debug / Output</div>
            <pre id="nutzenDebug" style="margin:0;padding:12px;border-radius:16px;border:1px solid var(--line);background:rgba(0,0,0,.20);overflow:auto;max-height:240px">{
  "headerset": "standard",
  "stress": "green",
  "roles": []
}</pre>
          </div>
        </div>
      </aside>

    </main>
  </div>

<!-- ===== OVERLAY ===== -->
<div id="nutzenOverlayBackdrop"
     class="backdrop"
     aria-hidden="true"
     onclick="closeNutzenOverlay()"></div>

<div id="nutzenOverlay" class="overlay" aria-hidden="true" role="dialog" aria-modal="true">
  <div class="overlayTop">
    <strong>Nutzen Overlay</strong>
    <button class="btn" type="button" onclick="closeNutzenOverlay()">Schließen</button>
  </div>

  <div class="overlayGrid overlayGridNew">
    <!-- Preis-Ranges: volle Breite -->
    <div class="card overlaySpan2" style="box-shadow:none">
      <h2>Preis Ranges</h2>
      <div class="body">
        <div class="row" style="gap:10px;flex-wrap:wrap">
          <div class="field" style="min-width:160px">
            <label for="ovFair">Fair Value (Override)</label>
            <input id="ovFair" placeholder="leer = aus Tabelle" />
          </div>
          <div class="field" style="min-width:120px">
            <label for="ovStrongBuyMult">Strong Buy</label>
            <input id="ovStrongBuyMult" placeholder="0,75" />
          </div>
          <div class="field" style="min-width:120px">
            <label for="ovBuyMult">Buy</label>
            <input id="ovBuyMult" placeholder="0,90" />
          </div>
          <div class="field" style="min-width:120px">
            <label for="ovHoldMult">Hold</label>
            <input id="ovHoldMult" placeholder="1,10" />
          </div>
          <div class="field" style="min-width:120px">
            <label for="ovExpensiveMult">Expensive</label>
            <input id="ovExpensiveMult" placeholder="1,25" />
          </div>
        </div>

<div class="row" style="margin-top:10px; gap:12px; align-items:flex-end; flex-wrap:wrap">
  <button class="btn" id="ovBuyReset" type="button">Reset</button>

  <!-- ✅ DCF Einstellungen EXTRA im Overlay -->
  <div class="card" style="box-shadow:none; padding:10px; border:1px solid var(--line); border-radius:16px; background:rgba(0,0,0,.10); flex:1; min-width:320px">
    <div class="muted" style="font-size:12px; margin-bottom:6px">DCF Einstellungen</div>

    <div class="row" style="gap:10px; flex-wrap:wrap">
      <div class="field" style="min-width:160px">
        <label for="ovDcfPresetOv">Preset</label>
        <select id="ovDcfPresetOv">
          <option value="eu">EU</option>
          <option value="usa">USA</option>
          <option value="middleeast">Middle East</option>
          <option value="china">China</option>
          <option value="defensive">Defensiv</option>
          <option value="normal">Normal</option>
          <option value="aggressive">Aggressiv</option>
          <option value="custom">Custom</option>
        </select>
      </div>

      <div class="field" style="min-width:110px">
        <label for="ovRfOv">rf %</label>
        <input id="ovRfOv" type="text" placeholder="3,00" />
      </div>

      <div class="field" style="min-width:110px">
        <label for="ovErpOv">ERP %</label>
        <input id="ovErpOv" type="text" placeholder="5,00" />
      </div>

      <div class="field" style="min-width:110px">
        <label for="ovGtOv">gT %</label>
        <input id="ovGtOv" type="text" placeholder="2,50" />
      </div>

      <div class="field" style="min-width:90px">
        <label for="ovYearsOv">Years</label>
        <input id="ovYearsOv" type="number" min="1" max="30" step="1" placeholder="5" />
      </div>
    </div>
  </div>
</div>

        <div style="margin-top:10px" id="nutzenOverlayBuyExplain">–</div>
        <div style="margin-top:8px" id="nutzenOverlayBuyDecision" class="chip">
          <span class="dot"></span> Aktion: –
        </div>
      </div>
    </div>

    <!-- Stress -->
    <div class="card" style="box-shadow:none">
      <h2>Stress Flag</h2>
      <div class="body">
        <div id="nutzenOverlayStressExplain">–</div>
      </div>
    </div>

    <!-- Rollen -->
    <div class="card" style="box-shadow:none">
      <h2>Rollen</h2>
      <div class="body">
        <div id="nutzenOverlayRolesExplain">–</div>
      </div>
    </div>
  </div>
</div>



  <script>
    console.log("SCRIPT START");
    window.NUTZEN_STATE = window.NUTZEN_STATE || {
  sector: "standard",
  buyBands: { strongBuy:0.75, buy:0.90, hold:1.10, expensive:1.25 }
};




window.goPage = function goPage(page){
  closeNutzenOverlay(); 
  const pages = document.querySelectorAll(".page");
  pages.forEach(p => p.classList.remove("isActive"));
  const elPage = document.getElementById("page-" + page);
  if(elPage) elPage.classList.add("isActive");
};

    // --- Overlay ---
    function openNutzenOverlay(){
       console.log("openNutzenOverlay()");
      const ov = document.getElementById("nutzenOverlay");
      const bd = document.getElementById("nutzenOverlayBackdrop");
      if(ov) ov.classList.add("isOpen");
      if(bd) bd.classList.add("isOpen");
      if(ov) ov.setAttribute("aria-hidden", "false");
      if(bd) bd.setAttribute("aria-hidden", "false");
        wireDcfInputsOverlay();
  syncDcfMainToOverlay();
    }
    function closeNutzenOverlay(){
      const ov = document.getElementById("nutzenOverlay");
      const bd = document.getElementById("nutzenOverlayBackdrop");
      if(ov) ov.classList.remove("isOpen");
      if(bd) bd.classList.remove("isOpen");
      if(ov) ov.setAttribute("aria-hidden", "true");
      if(bd) bd.setAttribute("aria-hidden", "true");
    }

    // --- Seiten Navigation ---
    function goPage(page){
      closeNutzenOverlay(); // verhindert "unsichtbares Overlay blockt Klicks"
      const pages = document.querySelectorAll(".page");
      pages.forEach(p => p.classList.remove("isActive"));
      const el = document.getElementById("page-" + page);
      if(el) el.classList.add("isActive");
    }

    // Mini-UX: Recalc Button placeholder
    document.getElementById("nutzenBtnRecalc")?.addEventListener("click", () => {
      const hs = document.getElementById("nutzenHeaderSet")?.value || "standard";
      const cagr = document.getElementById("nutzenCagrYear")?.value || "4";
      const vol = document.getElementById("nutzenVolYear")?.value || "1";
      const dbg = {
        headerset: hs,
        cagrYear: cagr,
        volYear: vol,
        stress: "green",
        roles: []
      };
      const pre = document.getElementById("nutzenDebug");
      if(pre) pre.textContent = JSON.stringify(dbg, null, 2);
    });

    



    // 1) Rollen-Liste (wie von dir)
const NUTZEN_ROLES = [
  "Dividenden Aristokrat",
  "Dividendenwachstum",
  "Value",
  "Wachstum",
  "Quality",
  "GARP",
  "Turnaround",
  "Zykliker",
  "Spekulation",
  "Krisenfall",
  "Defensiv",
  "stabil Defensiv",
  "Gesund",
  "Pricing Power",
  "Abo Modell/ Recurring Revenue",
  "Balance Sheet Strong",
  "Schuldenlastig/ Leveraged",
  "Small Cap",
  "Mid Cap",
  "Large Cap",
  "Mega Cap",
];

// 2) Sektoren
const NUTZEN_SECTORS = [
  { key:"standard", label:"Standard" },
  { key:"banks", label:"Banken" },
  { key:"insurance", label:"Versicherer" },
  { key:"reits", label:"REITS/ Immobilien" },
  { key:"utilities", label:"Utilities/ Versorger" },
  { key:"brokers", label:"Broker/Asset Manager" },
  { key:"commodities", label:"Rohstoffe/ Exploration" },
];

// 3) Kriterien je Sektor (nur Beispiel-Start; hier später deine echten Listen rein)



// Vollständige CRITERIA-Registry für ALLE Header aus deinen Sektoren.
// -> stabile IDs + label + aliases (für Paste / unterschiedliche Schreibweisen)

const CRITERIA = {
  // =====================
  // Kurs / Risiko
  // =====================
PRICE_NOW: {
  label: "Kurs aktuell",
  aliases: [
    "Kurs aktuell", "Price", "Current Price", "Aktueller Kurs",
    "open Kurs aktuell", "Open Kurs aktuell", "open price", "Open Price"
  ]
  },
  CAGR_4Y: {
    label: "Kurs 4Y (CAGR)",
    aliases: ["Kurs 4Y (CAGR)", "4Y CAGR", "Price 4Y CAGR", "CAGR 4Y"]
  },
  VOL_1_5_10: {
    label: "Volatilität annualisiert (Std-Abw.) 1Y/5Y/10Y",
    aliases: [
      "Volatilität annualisiert (Std-Abw.) 1Y/5Y/10Y",
      "Volatility annualized 1Y/5Y/10Y",
      "Volatility 1Y/5Y/10Y",
      "Volatilität 1Y/5Y/10Y"
    ]
  },
  BETA: {
    label: "Beta",
    aliases: ["Beta"]
  },
  RANGE_52W: {
    label: "52-Week Range",
    aliases: ["52-Week Range", "52 Week Range", "52W Range"]
  },
  PRICE_CHANGE_52W: {
    label: "52-Week Price Change",
    aliases: ["52-Week Price Change", "52 Week Price Change", "52W Price Change"]
  },

  // =====================
  // Größe / Bewertung / Multiples
  // =====================
  MARKET_CAP: {
    label: "Marktkapitalisierung",
    aliases: ["Marktkapitalisierung", "Market Cap", "Market Capitalization"]
  },
  ENTERPRISE_VALUE: {
    label: "Enterprise Value",
    aliases: ["Enterprise Value", "EV"]
  },
  FAIR_VALUE: {
    label: "Fairer Preis",
    aliases: ["Fairer Preis", "Fair Value", "Fair price", "Fair Value Estimate"]
  },
  PE_1Y: {
    label: "KGV (PE Ratio) 1Y",
    aliases: ["KGV (PE Ratio) 1Y", "PE Ratio 1Y", "P/E 1Y", "P/E Ratio 1Y"]
  },
  PB: {
    label: "P/B",
    aliases: ["P/B", "P/B Ratio", "Price to Book", "Price/Book"]
  },
  PB_RATIO: {
    label: "P/B Ratio",
    aliases: ["P/B Ratio", "P/B", "Price to Book", "Price/Book"]
  },
  PTBV: {
    label: "P/TBV",
    aliases: ["P/TBV", "Price to Tangible Book", "Price/Tangible Book"]
  },
  PTBV_RATIO: {
    label: "P/TBV Ratio",
    aliases: ["P/TBV Ratio", "P/TBV", "Price to Tangible Book", "Price/Tangible Book"]
  },
  EV_EBITDA_1Y: {
    label: "EV/EBITDA Ratio 1Y",
    aliases: ["EV/EBITDA Ratio 1Y", "EV/EBITDA 1Y", "EV/EBITDA Ratio (1Y)"]
  },
  EV_EBITDA: {
    label: "EV/EBITDA Ratio",
    aliases: ["EV/EBITDA Ratio", "EV/EBITDA", "EV/ EBITDA Ratio", "EV/ EBITDA Ratio 1Y"]
  },
  EV_EBITDA_RATIO: {
    label: "EV/EBITDA Ratio",
    aliases: ["EV/EBITDA Ratio", "EV/EBITDA", "EV/ EBITDA Ratio"]
  },
  P_FCF_1Y: {
    label: "P/FCF Ratio 1Y",
    aliases: ["P/FCF Ratio 1Y", "P/FCF 1Y", "Price/FCF 1Y", "P/FCF Ratio"]
  },
  P_FCF: {
    label: "P/FCF Ratio",
    aliases: ["P/FCF Ratio", "P/FCF", "Price/FCF"]
  },
  EV_FCF: {
    label: "EV/FCF Ratio",
    aliases: ["EV/FCF Ratio", "EV/FCF", "EV/FCF Ratio 1Y"]
  },
  EV_FCF_RATIO: {
    label: "EV/FCF Ratio",
    aliases: ["EV/FCF Ratio", "EV/FCF", "EV/FCF Ratio 1Y"]
  },

  // =====================
  // Wachstum / Umsatz / EPS
  // =====================
  REV_CAGR_4Y: {
    label: "Revenue 4Y (CAGR)",
    aliases: ["Revenue 4Y (CAGR)", "Revenue CAGR 4Y", "Umsatz 4Y (CAGR)"]
  },
  REV_GROWTH_YOY_1Y: {
    label: "Revenue Growth 1Y (YoY)",
    aliases: ["Revenue Growth 1Y (YoY)", "Revenue Growth (YoY)", "Umsatzwachstum (YoY)"]
  },
  REV_GROWTH_YOY: {
    label: "Revenue Growth (YoY)",
    aliases: ["Revenue Growth (YoY)", "Revenue Growth YoY", "Revenue Growth 1Y (YoY)"]
  },
  REVENUE_FY: {
    label: "Revenue (FY)",
    aliases: ["Revenue (FY)", "Revenue FY", "Umsatz (FY)"]
  },
  REVENUE_TTM: {
    label: "Revenue (TTM)",
    aliases: ["Revenue (TTM)", "Revenue TTM", "Umsatz (TTM)"]
  },
  TOTAL_REVENUE: {
    label: "Total Revenue",
    aliases: ["Total Revenue", "Gesamtumsatz"]
  },

  EPS_GROWTH_CAGR_4Y: {
    label: "EPS Growth 4Y (CAGR)",
    aliases: ["EPS Growth 4Y (CAGR)", "EPS CAGR 4Y", "EPS Growth CAGR 4Y"]
  },
  EPS_DILUTED: {
    label: "EPS (Diluted)",
    aliases: ["EPS (Diluted)", "Diluted EPS", "EPS Diluted"]
  },
  EPS_GROWTH: {
    label: "EPS Growth",
    aliases: ["EPS Growth", "EPS Growth (YoY)", "EPS Wachstum"]
  },
  EPS_TTM: {
    label: "EPS (TTM)",
    aliases: ["EPS (TTM)", "EPS TTM"]
  },
  EPS: {
    label: "EPS",
    aliases: ["EPS", "Earnings Per Share (EPS)", "Earnings Per Share"]
  },
  EPS_1Y: {
    label: "Earnings Per Share (EPS)",
    aliases: ["Earnings Per Share (EPS)", "EPS", "Earnings Per Share"]
  },

  // =====================
  // Margen / Profitabilität / Returns
  // =====================
  OP_MARGIN_1Y: {
    label: "Operating Margin 1Y",
    aliases: ["Operating Margin 1Y", "Operating Margin (1Y)"]
  },
  OP_MARGIN: {
    label: "Operating Margin",
    aliases: ["Operating Margin", "Operating Margin 1Y"]
  },
  PROFIT_MARGIN_1Y: {
    label: "Profit Margin 1Y",
    aliases: ["Profit Margin 1Y", "Profit Margin (1Y)"]
  },

        // =====================
  // Margen / Profitabilität / Returns
  // =====================
  GROSS_MARGIN_1Y: {
    label: "Gross Margin 1Y",
    aliases: [
      "Gross Margin 1Y",
      "Gross Margin (1Y)",
      "Gross Margin",
      "Bruttomarge 1Y",
      "Bruttomarge",
      "Gross Profit Margin 1Y",
      "Gross Profit Margin"
    ]
  },

  PROFIT_MARGIN: {
    label: "Profit Margin",
    aliases: ["Profit Margin", "Profit Margin 1Y"]
  },
  ROIC_1Y: {
    label: "ROIC 1Y",
    aliases: ["ROIC 1Y", "ROIC", "Return on Invested Capital (ROIC)"]
  },
  ROE_1Y: {
    label: "ROE 1Y",
    aliases: ["ROE 1Y", "ROE", "Return on Equity (ROE)"]
  },
  ROA_1Y: {
    label: "ROA 1Y",
    aliases: ["ROA 1Y", "ROA", "Return on Assets (ROA)"]
  },
  NET_INCOME_1Y: {
    label: "Net Income 1Y",
    aliases: ["Net Income 1Y", "Net Income (1Y)"]
  },
  NET_INCOME: {
    label: "Net Income",
    aliases: ["Net Income", "Net Income 1Y"]
  },
  NET_INCOME_TTM: {
    label: "Net Income (TTM)",
    aliases: ["Net Income (TTM)", "Net Income TTM"]
  },
  NET_INCOME_GROWTH: {
    label: "Net Income Growth",
    aliases: ["Net Income Growth", "Net Income Growth (YoY)"]
  },
  SHARES_OUT_DILUTED_1Y: {
  label: "Shares Outstanding (diluted) 1Y",
  aliases: [
    "Shares Outstanding (diluted) 1Y",
    "Shares Outstanding (Diluted) 1Y",
    "Shares Outstanding Diluted 1Y",
    "Shares Outstanding (diluted)",
    "Diluted Shares Outstanding",
    "Weighted Avg Shares Diluted",
    "Weighted Average Shares Diluted"
  ]
},
CASH_STI_1Y: {
  label: "Cash & Short-Term Investments 1Y",
  aliases: [
    "Cash & Short-Term Investments 1Y",
    "Cash & Short-Term Investments",
    "Cash and Short-Term Investments 1Y",
    "Cash and Short-Term Investments",
    "Cash & Short Term Investments 1Y",
    "Cash & Short Term Investments"
  ]
},
TOTAL_DEBT_1Y: {
  label: "Total Debt 1Y",
  aliases: [
    "Total Debt 1Y",
    "Total Debt (1Y)",
    "Total Debt",
    "Gesamtschulden 1Y",
    "Total Dept 1Y" // falls Excel-Tippfehler
  ]
},


  // =====================
  // Cashflow / FCF / Capex
  // =====================
  OCF_1Y: {
    label: "Operating Cash Flow 1Y",
    aliases: ["Operating Cash Flow 1Y", "Operating Cash Flow (1Y)"]
  },
  OCF: {
    label: "Operating Cash Flow",
    aliases: ["Operating Cash Flow", "Operating Cash Flow 1Y"]
  },
  CAPEX_1Y: {
    label: "Capital Expenditures 1Y",
    aliases: ["Capital Expenditures 1Y", "CapEx 1Y", "Capital Expenditures (1Y)"]
  },
  CAPEX: {
    label: "Capital Expenditures",
    aliases: ["Capital Expenditures", "CapEx"]
  },
  FCF_1Y: {
    label: "FCF 1Y",
    aliases: ["FCF 1Y", "Free Cash Flow 1Y", "Free Cash Flow (1Y)"]
  },
  FREE_CASH_FLOW: {
    label: "Free Cash Flow",
    aliases: ["Free Cash Flow", "FCF", "Free Cash Flow 1Y"]
  },
  FCF_MARGIN_1Y: {
    label: "FCF-Marge 1Y",
    aliases: ["FCF-Marge 1Y", "FCF Margin 1Y", "FCF Margin"]
  },
  FCF_MARGIN: {
    label: "FCF Margin",
    aliases: ["FCF Margin", "FCF-Marge 1Y", "FCF Margin 1Y"]
  },
  FCF_POSITIVE_YN: {
    label: "FCF positiv (Ja/Nein)",
    aliases: ["FCF positiv (Ja/Nein)", "FCF Positive (Yes/No)", "FCF positive"]
  },
  FCF_PER_SHARE: {
    label: "FCF Per Share",
    aliases: ["FCF Per Share", "Free Cash Flow Per Share", "FCF/Share"]
  },
  FCF_YIELD_1Y: {
    label: "FCF Yield 1Y",
    aliases: ["FCF Yield 1Y", "FCF Yield", "Free Cash Flow Yield 1Y"]
  },

  // =====================
  // Verschuldung / Liquidität / Zinsdeckung
  // =====================
  NET_DEBT_EBITDA_1Y: {
    label: "Net Debt / EBITDA Ratio 1Y",
    aliases: ["Net Debt / EBITDA Ratio 1Y", "Net Debt / EBITDA", "Net Debt/EBITDA 1Y"]
  },
  NET_DEBT_EBITDA: {
    label: "Net Debt / EBITDA",
    aliases: ["Net Debt / EBITDA", "Net Debt/EBITDA", "Net Debt / EBITDA 1Y"]
  },
  INTEREST_COVERAGE_1Y: {
    label: "Zinsdeckung 1Y (Interest Coverage)",
    aliases: ["Zinsdeckung 1Y (Interest Coverage)", "Interest Coverage 1Y", "Interest Coverage"]
  },
  INTEREST_COVERAGE: {
    label: "Interest Coverage",
    aliases: ["Interest Coverage", "Zinsdeckung 1Y (Interest Coverage)"]
  },
  CURRENT_RATIO_1Y: {
    label: "Current Ratio 1Y",
    aliases: ["Current Ratio 1Y", "Current Ratio (1Y)", "Current Ratio"]
  },
  CURRENT_RATIO: {
    label: "Current Ratio",
    aliases: ["Current Ratio", "Current Ratio 1Y"]
  },
  QUICK_RATIO_1Y: {
    label: "Quick Ratio 1Y",
    aliases: ["Quick Ratio 1Y", "Quick Ratio (1Y)", "Quick Ratio"]
  },
  QUICK_RATIO: {
    label: "Quick Ratio",
    aliases: ["Quick Ratio", "Quick Ratio 1Y"]
  },

  TOTAL_DEBT: {
    label: "Total Debt",
    aliases: ["Total Debt", "Gesamtschulden"]
  },
  NET_DEBT: {
    label: "Net Debt",
    aliases: ["Net Debt", "Nettoverschuldung"]
  },
  DEBT_EQUITY_RATIO: {
    label: "Debt / Equity Ratio",
    aliases: ["Debt / Equity Ratio", "Debt/Equity Ratio", "D/E Ratio"]
  },
  NET_DEBT_EQUITY_RATIO: {
    label: "Net Debt / Equity Ratio",
    aliases: ["Net Debt / Equity Ratio", "Net Debt/Equity Ratio"]
  },
  DEBT_FCF_RATIO: {
    label: "Debt / FCF Ratio",
    aliases: ["Debt / FCF Ratio", "Debt/FCF Ratio"]
  },
  DEBT_EBITDA_RATIO: {
    label: "Debt / EBITDA Ratio",
    aliases: ["Debt / EBITDA Ratio", "Debt/EBITDA Ratio"]
  },
  DEBT_EQUITY: {
    label: "Debt / Equity",
    aliases: ["Debt / Equity", "Debt/Equity"]
  },

  // =====================
  // Dividende / Shareholder Return
  // =====================
  DIV_PER_YEAR: {
    label: "Dividende (p.a.)",
    aliases: ["Dividende (p.a.)", "Dividend (annual)", "Dividend per year"]
  },
  DIV_FREQUENCY: {
    label: "Div.-Frequency",
    aliases: ["Div.-Frequency", "Dividend Frequency", "Frequency"]
  },
  DIV_YIELD: {
    label: "Div.-Rendite aktuell (%)",
    aliases: ["Div.-Rendite aktuell (%)", "Dividend Yield", "Dividend Yield (%)"]
  },


    // =====================
  // Dividende / Shareholder Return
  // =====================
  DIVIDEND_DPS_CAGR_4Y: {
    label: "Dividende (DPS) 4Y (CAGR)",
    aliases: [
      "Dividende (DPS) 4Y (CAGR)",
      "Dividende (DPS) 4Y (CAGR)",          // bewusst doppelt ok (copy/paste safe)
      "DPS (CAGR) 4Y",
      "DPS CAGR 4Y",
      "Dividend Per Share (CAGR) 4Y",
      "Dividend Per Share CAGR 4Y",
      "DPS Dividend Per Share (CAGR) 4Y",
      "Dividende pro Aktie (CAGR) 4Y"
    ]
  },


  DIV_GROWTH_YEARS: {
    label: "Dividend Growth years",
    aliases: ["Dividend Growth years", "Dividend Growth Years"]
  },
  DIV_GROWTH: {
    label: "Dividend Growth",
    aliases: ["Dividend Growth", "Dividend Growth (YoY)"]
  },
  DIV_GROWTH_YOY: {
    label: "Dividend Growth (YoY)",
    aliases: ["Dividend Growth (YoY)", "Dividend Growth", "Dividend Growth YoY"]
  },
  PAYOUT_RATIO_1Y: {
    label: "Payout Ratio 1Y",
    aliases: ["Payout Ratio 1Y", "Payout Ratio", "Dividend Payout Ratio 1Y"]
  },
  BUYBACK_YIELD: {
    label: "Buyback Yield",
    aliases: ["Buyback Yield"]
  },
  SHAREHOLDER_YIELD: {
    label: "Shareholder Yield",
    aliases: ["Shareholder Yield"]
  },
  SHARES_CHANGE_YOY: {
    label: "Shares Change (YoY)",
    aliases: ["Shares Change (YoY)", "Shares Change YoY", "Shares Outstanding Change (YoY)"]
  },

  // =====================
  // Banken-spezifisch
  // =====================
  NET_INTEREST_INCOME_1Y: {
    label: "Net Interest Income 1Y",
    aliases: ["Net Interest Income 1Y", "Net Interest Income"]
  },
  NET_INTEREST_INCOME_GROWTH_YOY: {
    label: "Net Interest Income Growth (YoY)",
    aliases: ["Net Interest Income Growth (YoY)", "NII Growth (YoY)"]
  },
  TOTAL_NON_INTEREST_INCOME: {
    label: "Total Non-Interest Income",
    aliases: ["Total Non-Interest Income", "Non-Interest Income"]
  },
  NON_INTEREST_INCOME_GROWTH_YOY: {
    label: "Non-Interest Income Growth (YoY)",
    aliases: ["Non-Interest Income Growth (YoY)"]
  },
  PROVISION_LOAN_LOSSES: {
    label: "Provision for Loan Losses",
    aliases: ["Provision for Loan Losses", "Loan Loss Provision"]
  },

  // =====================
  // Versicherer-spezifisch
  // =====================
  PREMIUMS_ANNUITY_REVENUE: {
    label: "Premiums & Annuity Revenue",
    aliases: ["Premiums & Annuity Revenue", "Premiums and Annuity Revenue"]
  },
  TOTAL_INTEREST_DIV_INCOME: {
    label: "Total Interest & Dividend Income",
    aliases: ["Total Interest & Dividend Income", "Interest & Dividend Income"]
  },
  POLICY_BENEFITS: {
    label: "Policy Benefits",
    aliases: ["Policy Benefits"]
  },
  SG_A: {
    label: "Selling, General & Administrative",
    aliases: ["Selling, General & Administrative", "SG&A", "SGA"]
  },
  OPERATING_INCOME: {
    label: "Operating Income",
    aliases: ["Operating Income"]
  },

  // =====================
  // REIT-spezifisch
  // =====================
  FFO: {
    label: "Funds From Operations (FFO)",
    aliases: ["Funds From Operations (FFO)", "FFO"]
  },
  AFFO: {
    label: "Adjusted Funds From Operations (AFFO)",
    aliases: ["Adjusted Funds From Operations (AFFO)", "AFFO"]
  },
  FFO_PAYOUT_RATIO: {
    label: "FFO Payout Ratio",
    aliases: ["FFO Payout Ratio"]
  },

  // =====================
  // Utilities / allgemein: EBITDA etc.
  // =====================
  EBITDA_1Y: {
    label: "EBITDA 1Y",
    aliases: ["EBITDA 1Y", "EBITDA (1Y)"]
  },
  EBITDA: {
    label: "EBITDA",
    aliases: ["EBITDA"]
  },
  EBITDA_MARGIN: {
    label: "EBITDA Margin",
    aliases: ["EBITDA Margin"]
  },

  // =====================
  // Commodities / zusätzliche Cash-KPIs
  // =====================
  GROSS_PROFIT: {
    label: "Gross Profit",
    aliases: ["Gross Profit"]
  },
  OPERATING_INCOME_IS: {
    label: "Operating Income",
    aliases: ["Operating Income"]
  },
  NET_CASH: {
    label: "Net Cash",
    aliases: ["Net Cash"]
  },
  NET_CASH_PER_SHARE: {
    label: "Net Cash Per Share",
    aliases: ["Net Cash Per Share"]
  },

  // =====================
  // Bilanz-Positionen (Banks/Insurance/REITs/…)
  // =====================
  TOTAL_ASSETS_1Y: {
    label: "Total Assets 1Y",
    aliases: ["Total Assets 1Y", "Total Assets"]
  },
  TOTAL_LIABILITIES_1Y: {
    label: "Total Liabilities 1Y",
    aliases: ["Total Liabilities 1Y", "Total Liabilities"]
  },
  EQUITY_1Y: {
    label: "Equity 1Y",
    aliases: ["Equity 1Y", "Equity"]
  },
  EQUITY_BOOK_VALUE: {
    label: "Equity (Book Value)",
    aliases: ["Equity (Book Value)", "Equity", "Book Value"]
  },
  BOOK_VALUE_PER_SHARE: {
    label: "Book Value per Share",
    aliases: ["Book Value per Share", "Book Value Per Share"]
  },
  CASH_EQUIV: {
    label: "Cash & Cash Equivalents",
    aliases: ["Cash & Cash Equivalents", "Cash and Cash Equivalents"],


    // neu


    // === CORE IDs (werden von Roles/Stress/DCF genutzt) ===
PRICE_NOW: { label:"Kurs aktuell", aliases:["Kurs aktuell","Price","Current Price","Aktueller Kurs","open Kurs aktuell","Open Kurs aktuell"] },
FAIR_VALUE:{ label:"Fairer Preis", aliases:["Fairer Preis","Fair Value","Fair price","Fair Value Estimate","Faier Preis","Faier Preis "] },

VOL_1_5_10: {
  label: "Volatilität annualisiert (ausgewähltes Jahr)",
  aliases: [
    "Volatilität annualisiert (Std-Abw.) 1Y/5Y/10Y",
    "Volatility annualized 1Y/5Y/10Y",
    "Volatility 1Y/5Y/10Y",
    "Volatilität 1Y/5Y/10Y"
  ]
},

PE_1Y:      { label:"KGV (PE Ratio) 1Y", aliases:["KGV (PE Ratio) 1Y","PE Ratio 1Y","P/E 1Y","P/E Ratio 1Y","PE Ration (KGV) 1Y"] },
EV_EBITDA_1Y:{ label:"EV/EBITDA Ratio 1Y", aliases:["EV/EBITDA Ratio 1Y","EV/EBITDA 1Y","EV/EBITDA Ratio (1Y)"] },
P_FCF_1Y:    { label:"P/FCF Ratio 1Y", aliases:["P/FCF Ratio 1Y","P/FCF 1Y","Price/FCF 1Y","P/FCF Ratio"] },

SHARES_CHANGE_YOY:{ label:"Shares Change (YoY)", aliases:["Shares Change (YoY)","Shares Change YoY","Shares Outstanding Change (YoY)"] },

FCF_POSITIVE_YN:{ label:"FCF positiv (Ja/Nein)", aliases:["FCF positiv (Ja/Nein)","FCF positiv ja/nein","FCF Positive (Yes/No)","FCF positive"] },
FCF_MARGIN_1Y:  { label:"FCF-Marge 1Y", aliases:["FCF-Marge 1Y","FCF Margin 1Y","FCF Margin"] },

REV_GROWTH_YOY_1Y:{ label:"Revenue Growth 1Y (YoY)", aliases:["Revenue Growth 1Y (YoY)","Revenue Growth (YoY)","Umsatzwachstum (YoY)"] },
EPS_GROWTH_CAGR_4Y:{ label:"EPS Growth 4Y (CAGR)", aliases:["EPS Growth 4Y (CAGR)","EPS CAGR 4Y","EPS (CAGR) 4Y","EPS Growth CAGR 4Y"] },

NET_DEBT_EBITDA_1Y:{ label:"Net Debt / EBITDA Ratio 1Y", aliases:["Net Debt / EBITDA Ratio 1Y","Net Debt/EBITDA 1Y","Net Debt/ EBITDA Ratio 1Y","Net Debt / EBITDA"] },
INTEREST_COVERAGE_1Y:{ label:"Zinsdeckung 1Y (Interest Coverage)", aliases:["Zinsdeckung 1Y (Interest Coverage)","Interest Coverage 1Y","Interest Coverage  1Y (Zinsdeckung)"] },
CURRENT_RATIO_1Y:{ label:"Current Ratio 1Y", aliases:["Current Ratio 1Y","Current Ratio (1Y)","Current Ratio"] },

CASH_STI_1Y:{ label:"Cash & Short-Term Investments 1Y", aliases:["Cash & Short-Term Investments 1Y","Cash & Short-Term Investments","Cash and Short-Term Investments 1Y","Cash and Short-Term Investments"] },
TOTAL_DEBT_1Y:{ label:"Total Debt 1Y", aliases:["Total Debt 1Y","Total Debt (1Y)","Total Debt","Total Dept 1Y","Total Dept 1Y "] },

PAYOUT_RATIO_1Y:{ label:"Payout Ratio 1Y", aliases:["Payout Ratio 1Y","Payout Ratio","Dividend Payout Ratio 1Y","Payout Ratio"] },



  },
};



function critIdFromHeaderText(headerText){
  const h = String(headerText || "").trim().toLowerCase();
  for(const [id, def] of Object.entries(CRITERIA)){
    const aliases = def.aliases || [def.label];
    if(aliases.some(a => String(a).trim().toLowerCase() === h)) return id;
  }
  return null;
}






const NUTZEN_HEADERS_BY_SECTOR = {
  standard: [
    // ===== Wachstum / Profitabilität =====
    "Revenue Growth 1Y (YoY)",
    "Revenue 4Y (CAGR)",
    "Shares Outstanding (diluted) 1Y",
    "EPS (Diluted)",
    "EPS Growth 4Y (CAGR)",

    // ===== Cashflow / FCF =====
    "FCF 1Y",
    "FCF positiv (Ja/Nein)",
    "Dividende (DPS) 4Y (CAGR)",

    "Gross Margin 1Y",
    "Operating Margin 1Y",
    "Profit Margin 1Y",

    // ===== Bilanz / Cash / Debt =====
    "Cash & Short-Term Investments 1Y",
    "Total Debt 1Y",

    // ===== Cashflow-Details =====
    "Net Income 1Y",
    "Operating Cash Flow 1Y",
    "Capital Expenditures 1Y",
    "FCF-Marge 1Y",

    // ===== Bewertung / Multiples =====
    "KGV (PE Ratio) 1Y",
    "P/FCF Ratio 1Y",
    "EV/EBITDA Ratio 1Y",

    // ===== Leverage / Liquidity / Returns =====
    "Net Debt / EBITDA Ratio 1Y",
    "Current Ratio 1Y",
    "ROE 1Y",
    "ROIC 1Y",
    "FCF Yield 1Y",

    // ===== Dividende / Shareholder =====
    "Div.-Rendite aktuell (%)",
    "Div.-Frequency",
    "Dividend Growth years",
    "Payout Ratio 1Y",
    "Buyback Yield",
    "Shareholder Yield",

    // ===== Size / Shares =====
    "Marktkapitalisierung",
    "Shares Change (YoY)",
    "Zinsdeckung 1Y (Interest Coverage)",

    // ===== Kurs / Risiko =====
    "Beta",
    "52-Week Range",
    "Kurs aktuell",
    "Volatilität annualisiert (Std-Abw.) 1Y/5Y/10Y",

    // ===== Fair Value =====
    "Fairer Preis",
  ],



banks: [
    
  ],


    insurance: [
    
  ],



  reits: [

  ],


  utilities: [
 
  ],


    brokers: [

  ],


  
commodities: [

  ],
  };





  // Werte-Only Paste: diese Reihenfolge kommt aus deinem Excel-Block
const PASTE_ORDER_STANDARD = [
  "Revenue Growth 1Y (YoY)",
  "Revenue 4Y (CAGR)",
  "Shares Outstanding (diluted) 1Y",
  "EPS (Diluted)",
  "EPS Growth 4Y (CAGR)",
  "FCF 1Y",
  "FCF positiv (Ja/Nein)",
  "Dividende (DPS) 4Y (CAGR)",
  "Gross Margin 1Y",
  "Operating Margin 1Y",
  "Profit Margin 1Y",
  "Cash & Short-Term Investments 1Y",
  "Total Debt 1Y",
  "Net Income 1Y",
  "Operating Cash Flow 1Y",
  "Capital Expenditures 1Y",
  "FCF-Marge 1Y",
  "KGV (PE Ratio) 1Y",
  "P/FCF Ratio 1Y",
  "EV/EBITDA Ratio 1Y",
  "Net Debt / EBITDA Ratio 1Y",
  "Current Ratio 1Y",
  "ROE 1Y",
  "ROIC 1Y",
  "FCF Yield 1Y",
  "Div.-Rendite aktuell (%)",
  "Div.-Frequency",
  "Dividend Growth years",
  "Payout Ratio 1Y",
  "Buyback Yield",
  "Shareholder Yield",
  "Marktkapitalisierung",
  "Shares Change (YoY)",
  "Zinsdeckung 1Y (Interest Coverage)",
  "Beta",
  "52-Week Range",
  "Kurs aktuell",
  "Volatilität annualisiert (Std-Abw.) 1Y/5Y/10Y",
  "Fairer Preis",
];







// Konvertiert deine alten Text-Header Arrays -> neue ID-Arrays.
// Debug: listet ALLE Header, die nicht gemappt werden konnten.
function convertHeadersToIds(headersBySector){
  const out = {};
  const missing = new Map(); // headerText -> [sector,...]

  for(const [sector, headers] of Object.entries(headersBySector || {})){
    out[sector] = [];
    for(const h of (headers || [])){
      const id = (typeof critIdFromHeaderText === "function") ? critIdFromHeaderText(h) : null;
      if(id){
        out[sector].push(id);
      } else {
        out[sector].push(normKey(h)); // fallback (damit nichts verloren geht)
        const arr = missing.get(h) || [];
        arr.push(sector);
        missing.set(h, arr);
      }
    }
  }

  console.group("convertHeadersToIds(): Missing CRITERIA mappings");
  if(missing.size === 0) console.log("✅ Keine fehlenden Header – alles gemappt.");
  else for(const [h, sectors] of missing.entries()) console.warn(`❌ "${h}"  ->  Sektoren: ${sectors.join(", ")}`);
  console.groupEnd();

  return out; // => NUTZEN_CRITERIA_BY_SECTOR
}


const NUTZEN_CRITERIA_BY_SECTOR = convertHeadersToIds(NUTZEN_HEADERS_BY_SECTOR);

// optional: für DevTools sichtbar machen
window.NUTZEN_CRITERIA_BY_SECTOR = NUTZEN_CRITERIA_BY_SECTOR;

console.log("standard ids:", NUTZEN_CRITERIA_BY_SECTOR.standard?.length);



  

// 4) Welche CAGR- und Vola-Jahre pro Sektor “erlaubt” sind (alles möglich)
const NUTZEN_YEARS_BY_SECTOR = {
  standard:   { cagr:[1,2,3,4], vol:[1,5,10] },
  banks:      { cagr:[1,2,3,4], vol:[1,5,10] },
  insurance:  { cagr:[1,2,3,4], vol:[1,5,10] },
  reits:      { cagr:[1,2,3,4], vol:[1,5,10] },
  utilities:  { cagr:[1,2,3,4], vol:[1,5,10] },
  brokers:    { cagr:[1,2,3,4], vol:[1,5,10] },
  commodities:{ cagr:[1,2,3,4], vol:[1,5,10] },
};



function normKey(s){
  return String(s || "")
    .trim()
    .toLowerCase()
    .replace(/\u00a0/g, " ")
    .replace(/\s+/g, " ")
    .replace(/[()]/g, "")
    .replace(/[–—]/g, "-")
    .trim();
}

// =============================
// 1) Missing / NA Tokens
// =============================
const NA_TOKENS = new Set([
  "", " ", "–", "-", "—",
  "n/a", "na", "n.a.", "n.a",
  "k.a.", "k.a",
  "null", "none", "undefined"
]);

function nzStr(v){
  if(v === null || v === undefined) return "";
  return String(v).trim();
}

function isMissing(v){
  const s = nzStr(v).toLowerCase();
  return NA_TOKENS.has(s);
}

// =============================
// Parser: nzNum + nzPct01 (ersetzen)
// - unterstützt DE/EN Zahlen + K/M/B/T
// - nzPct01 gibt IMMER 0..1 zurück
// =============================
function nzNum(v){
  if(isMissing(v)) return NaN;

  let s = nzStr(v).replace(/\s/g, "");
  if(!s) return NaN;

  // Prozentzeichen für nzNum ignorieren (nzPct01 macht daraus ratio)
  s = s.replace("%", "");

  // K/M/B/T suffix (z.B. 2.3B, 150M, 12k)
  const mm = s.match(/^([-+]?[\d.,]+)([kmbt])$/i);
  if(mm){
    let n = mm[1];
    const suf = mm[2].toLowerCase();

    // DE -> EN
    if(n.includes(",") && n.includes(".")){
      n = n.replace(/\./g, "").replace(",", ".");
    } else if(n.includes(",")){
      n = n.replace(",", ".");
    }

    let val = Number(n);
    if(!Number.isFinite(val)) return NaN;

    const mult = suf === "k" ? 1e3 :
                 suf === "m" ? 1e6 :
                 suf === "b" ? 1e9 :
                 suf === "t" ? 1e12 : 1;
    return val * mult;
  }

  // DE -> EN
  if(s.includes(",") && s.includes(".")){
    s = s.replace(/\./g, "").replace(",", ".");
  } else if(s.includes(",")){
    s = s.replace(",", ".");
  }

  const n = Number(s);
  return Number.isFinite(n) ? n : NaN;
}

function nzPct01(v){
  const n = nzNum(v);
  if(!Number.isFinite(n)) return NaN;
  // Heuristik: 12 => 12% => 0.12, 0.12 bleibt 0.12
  return (Math.abs(n) > 1.5) ? (n / 100) : n;
}

function el(id){ return document.getElementById(id); }

function fmtNum(n){
  if(!Number.isFinite(n)) return "–";
  // DE-Format (optional)
  return n.toLocaleString("de-DE", { maximumFractionDigits: 2 });
}



function parseRangeLowHigh(v){
  if(isMissing(v)) return null;
  const s = nzStr(v).replace(/\u00a0/g," ").trim();

  const m = s.match(/^(.+?)\s*-\s*(.+?)$/);
  if(!m) return null;

  const low = nzNum(m[1]);
  const high = nzNum(m[2]);
  if(!Number.isFinite(low) || !Number.isFinite(high)) return null;

  return { low, high };
}



function syncDcfMainToOverlay(){
  const a = el("ovDcfPreset"), b = el("ovDcfPresetOv");
  const rf1 = el("ovRf"),      rf2 = el("ovRfOv");
  const e1  = el("ovErp"),     e2  = el("ovErpOv");
  const gt1 = el("ovGt"),      gt2 = el("ovGtOv");
  const y1  = el("ovYears"),   y2  = el("ovYearsOv");

  if(a && b)  b.value  = a.value;
  if(rf1 && rf2) rf2.value = rf1.value;
  if(e1 && e2)  e2.value  = e1.value;
  if(gt1 && gt2) gt2.value = gt1.value;
  if(y1 && y2)  y2.value  = y1.value;
}

function syncDcfOverlayToMain(){
  const a = el("ovDcfPreset"), b = el("ovDcfPresetOv");
  const rf1 = el("ovRf"),      rf2 = el("ovRfOv");
  const e1  = el("ovErp"),     e2  = el("ovErpOv");
  const gt1 = el("ovGt"),      gt2 = el("ovGtOv");
  const y1  = el("ovYears"),   y2  = el("ovYearsOv");

  if(a && b)  a.value  = b.value;
  if(rf1 && rf2) rf1.value = rf2.value;
  if(e1 && e2)  e1.value  = e2.value;
  if(gt1 && gt2) gt1.value = gt2.value;
  if(y1 && y2)  y1.value  = y2.value;
}



function wireDcfInputsOverlay(){
  if(wireDcfInputsOverlay._bound) return;

  const presetSel = el("ovDcfPresetOv");
  const rfEl  = el("ovRfOv");
  const erpEl = el("ovErpOv");
  const gtEl  = el("ovGtOv");
  const yEl   = el("ovYearsOv");

  if(!presetSel || !rfEl || !erpEl || !gtEl || !yEl) return;
  wireDcfInputsOverlay._bound = true;

  // initial sync
  syncDcfMainToOverlay();

  // Preset change: -> Main spiegeln -> Preset anwenden -> zurück spiegeln
  presetSel.addEventListener("change", () => {
    syncDcfOverlayToMain();

    if(presetSel.value !== "custom") {
      applyDcfPreset(presetSel.value);  // arbeitet auf MAIN IDs
    }

    syncDcfMainToOverlay();
    runAllCalcs();
  });

  // Manuelle Eingabe: overlay -> main, preset=custom, recalc
  const onManual = () => {
    syncDcfOverlayToMain();

    const mainPreset = el("ovDcfPreset");
    if(mainPreset) mainPreset.value = "custom";
    presetSel.value = "custom";

    runAllCalcs();
  };

  rfEl.addEventListener("input", onManual);
  erpEl.addEventListener("input", onManual);
  gtEl.addEventListener("input", onManual);
  yEl.addEventListener("input",  onManual);
}




 // --- Helpers ---



 function trigIcon(t){
  if(t.missing) return "—";
  if(t.bad) return "❌";
  return "✅";
}

function normalizeTriggers(list){
  const arr = Array.isArray(list) ? list : [];
  // Erwartetes Format: { label, bad:boolean, missing:boolean }
  return arr.map(x => ({
    label: x.label || x.name || x.key || "Trigger",
    bad: !!x.bad,
    missing: !!x.missing
  }));
}


function countBySev(trigs){
  const arr = trigs || [];
  const relevant = arr.filter(t => !t.missing);

  const warnBad = relevant.filter(t => t.bad && (t.sev || "warn") === "warn").length;
  const critBad = relevant.filter(t => t.bad && (t.sev || "warn") === "critical").length;

  return { warnBad, critBad, bad: warnBad + critBad, total: relevant.length };
}





function computeFairValueStandardDCF(ctx){
  // ✅ rf/erp/gT/years aus UI + Preset
  const cfg = readDcfSettingsFromUI(); // { rf, erp, gT, years } als Dezimalwerte

  const fcf    = ctx.num("FCF_1Y");
  const shares = ctx.num("SHARES_OUT_DILUTED_1Y");
  const cash   = ctx.num("CASH_STI_1Y");
  const debt   = ctx.num("TOTAL_DEBT_1Y");
  const beta   = ctx.num("BETA");

  // Mindestanforderungen
  if(!Number.isFinite(fcf) || !Number.isFinite(shares) || shares <= 0) return NaN;

  // ✅ g kommt NUR aus Revenue CAGR 4Y
  const g = ctx.pct("REV_CAGR_4Y");
  if(!Number.isFinite(g)) return NaN;

  // Diskontsatz per CAPM
  const b = Number.isFinite(beta) ? beta : 1.0;
  const disc = cfg.rf + b * cfg.erp;

  // Terminal Value Bedingung
  if(!(disc > cfg.gT)) return NaN;

  // PV der Jahre 1..N
  let pv = 0;
  for(let t=1; t<=cfg.years; t++){
    const ft = fcf * Math.pow(1 + g, t);
    pv += ft / Math.pow(1 + disc, t);
  }

  // Terminal Value (Gordon Growth)
  const fN = fcf * Math.pow(1 + g, cfg.years);
  const tv = (fN * (1 + cfg.gT)) / (disc - cfg.gT);
  const pvTV = tv / Math.pow(1 + disc, cfg.years);

  const enterpriseValue = pv + pvTV;

  // Net Debt = Debt - Cash
  let netDebt = NaN;
  if(Number.isFinite(debt) && Number.isFinite(cash)){
    netDebt = debt - cash;
  }

  const equityValue = Number.isFinite(netDebt)
    ? (enterpriseValue - netDebt)
    : enterpriseValue;

  return equityValue / shares;
}



function syncOvFairDefaultFromData(m){
  const ov = el("ovFair");
  if(!ov) return;

  // ✅ Wenn User gerade tippt: NIEMALS auto-überschreiben
  if(document.activeElement === ov) return;

  // ✅ Wenn schon Wert drin: nicht überschreiben
  if(nzStr(ov.value).trim().length > 0) return;

  const fairFromTable = nzNum(mGet(m, "FAIR_VALUE"));
  const fairFromInput = nzNum(el("nutzenFairValue")?.value);

  const fair = Number.isFinite(fairFromInput) ? fairFromInput : fairFromTable;

  if(Number.isFinite(fair) && fair > 0){
    ov.value = String(fair).replace(".", ","); // optional DE
  }
}



 function setDot(dotEl, mode){
  if(!dotEl) return;
  dotEl.classList.remove("good","warn","bad","darkbad");
  if(mode) dotEl.classList.add(mode);
}

function fmtDE(n){
  return Number.isFinite(n) ? n.toLocaleString("de-DE",{maximumFractionDigits:2}) : "–";
}

function renderAktuellerZustand({ roles, st, buy }){
  // ---- Stress Chip ----
  setDot(el("dotStress"), st?.mode);
  const tStress = el("txtStress");
  if(tStress) tStress.textContent = `Stress: ${st?.label ?? "–"}`;

  // ---- Rollen: ALLE aktiven Rollen ----
  const act = (roles || []).filter(r => r.active);
  const rolesText = act.length ? act.map(r => r.role).join(", ") : "–";
  setDot(el("dotRole"), act.length ? "good" : "warn");
  const tRoleChip = el("txtRole");
  if(tRoleChip) tRoleChip.textContent = `Rolle(n): ${act.length ? act.length : "–"}`;

  const tRolesAll = el("txtRolesAll");
  if(tRolesAll) tRolesAll.textContent = rolesText;

  // ---- Price Ranges + Buy Chip ----
  const dec = computeBuyDecision(buy?.priceNow, buy?.fair, buy?.bands);
  setDot(el("dotBuy"), dec?.mode);
  const tBuy = el("txtBuy");
  if(tBuy) tBuy.textContent = `Buy: ${dec?.label ?? "–"}`;

  const tRanges = el("txtRanges");
  if(tRanges){
    const b = buy?.bands;
    tRanges.textContent = b
      ? `Kurs: ${fmtDE(buy.priceNow)} | Fair: ${fmtDE(buy.fair)} | Strong Buy ≤ ${fmtDE(b.strongBuyMax)} | Buy ≤ ${fmtDE(b.buyMax)} | Hold ≤ ${fmtDE(b.holdMax)} | Expensive > ${fmtDE(b.expensiveMax)}`
      : `Kurs: ${fmtDE(buy?.priceNow)} | Fair: ${fmtDE(buy?.fair)} | Buy-Bands: –`;
  }
}




function summarizeRolesAll(evRoles){
  const act = (evRoles || []).filter(r => r.active).map(r => r.role);
  return act.length ? act.join(", ") : "–";
}


  function updateNutzenTableFromMap(valMap){
    const tbody = document.getElementById("nutzenTableBody");
    if(!tbody) return;

    // bestehende Tabellenzeilen auslesen: 1. Spalte = Header
    const trs = Array.from(tbody.querySelectorAll("tr"));

    // wenn du willst: fehlende Header aus dem Paste automatisch ergänzen
    // (standardmäßig: wir updaten nur vorhandene Zeilen)
    const allowAppendMissing = true;

    const seen = new Set();

    // 1) vorhandene Zeilen updaten
    for(const tr of trs){
      const tds = tr.querySelectorAll("td");
      if(tds.length < 2) continue;

      const headerText = (tds[0].textContent || "").trim();
      const key = normKey(headerText);

      if(valMap.has(key)){
        tds[1].textContent = valMap.get(key);
        // optional Notiz löschen/setzen
        if(tds[2]) tds[2].textContent = "";
        seen.add(key);
      }
    }

    // 2) fehlende Headers aus dem Paste anhängen (optional)
    if(allowAppendMissing){
      for(const [k,v] of valMap.entries()){
        if(seen.has(k)) continue;

        // Original Header-Text rekonstruieren geht nicht perfekt,
        // daher nehmen wir den Key "schön" formatiert:
        const pretty = k.replace(/\b\w/g, m => m.toUpperCase());

        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td class="muted">${pretty}</td>
          <td>${v}</td>
          <td class="muted">eingefügt</td>
        `;
        tbody.appendChild(tr);
      }
    }
  }


function renderOverlaySummary(summary){
  // Rollen kurz
  const rEl = el("nutzenOverlayRolesExplain");
  if(rEl) rEl.textContent = `Rollen: ${summary?.rolesText ?? "–"}`;

  // Stress kurz
  const sEl = el("nutzenOverlayStressExplain");
  if(sEl) sEl.textContent = `Stress: ${summary?.stressLabel ?? "–"}`;

  // Price Bands kurz
  const bEl = el("nutzenOverlayBuyExplain");
  if(bEl){
    const _fair  = summary?.fair;
    const _bands = summary?.bands;

    const fmt = (n) => Number.isFinite(n)
      ? n.toLocaleString("de-DE", { maximumFractionDigits: 2 })
      : "–";

    const line = (_bands && Number.isFinite(_fair))
      ? `Fair: ${fmt(_fair)} | Strong Buy ≤ ${fmt(_bands.strongBuyMax)} | Buy ≤ ${fmt(_bands.buyMax)} | Hold ≤ ${fmt(_bands.holdMax)} | Expensive > ${fmt(_bands.expensiveMax)}`
      : `Fair: ${fmt(_fair)} | Buy-Bands: –`;

    bEl.textContent = line;
  }
}



// liest "0,75" oder "0.75" -> Number
function nzNumInput(v){
  const s = nzStr(v).replace(/\s/g,"");
  if(!s) return NaN;
  return nzNum(s); // nutzt deinen vorhandenen nzNum (kann Komma/DE)
}




function computeBuyBandsFromFair(fair, bands){
  if(!Number.isFinite(fair) || fair <= 0) return null;
  return {
    strongBuyMax: fair * (bands.strongBuy ?? 0.75),
    buyMax:       fair * (bands.buy ?? 0.90),
    holdMax:      fair * (bands.hold ?? 1.10),
    expensiveMax: fair * (bands.expensive ?? 1.25),
  };
}

function computeBuyDecision(priceNow, fair, bands){
  if(!Number.isFinite(priceNow) || !Number.isFinite(fair) || !bands) return { label:"–", mode:"" };

  if(priceNow <= bands.strongBuyMax) return { label:"Strong Buy", mode:"good" };
  if(priceNow <= bands.buyMax)       return { label:"Buy",       mode:"good" };
  if(priceNow <= bands.holdMax)      return { label:"Hold",      mode:"warn" };
  if(priceNow <= bands.expensiveMax) return { label:"Expensive", mode:"bad" };
  return { label:"Very Expensive", mode:"darkbad" };
}




function wireOverlayBuyInputs(){
  const ovFair = el("ovFair");
  const sb = el("ovStrongBuyMult");
  const b  = el("ovBuyMult");
  const h  = el("ovHoldMult");
  const ex = el("ovExpensiveMult");
  const reset = el("ovBuyReset");

  if(!sb || !b || !h || !ex) return;

  // nur einmal binden
  if(wireOverlayBuyInputs._bound) return;
  wireOverlayBuyInputs._bound = true;

  // manuelles Override markieren
  ovFair?.addEventListener("input", () => {
    ovFair.dataset.auto = "0";
    runAllCalcs();
  });

  function syncInputsFromState(){
    sb.value = String(NUTZEN_STATE.buyBands.strongBuy ?? 0.75);
    b.value  = String(NUTZEN_STATE.buyBands.buy ?? 0.90);
    h.value  = String(NUTZEN_STATE.buyBands.hold ?? 1.10);
    ex.value = String(NUTZEN_STATE.buyBands.expensive ?? 1.25);
  }
  syncInputsFromState();

  function normalizeBands(obj){
    const clamp = (x,min,max)=>Math.max(min, Math.min(max, x));
    let strongBuy = clamp(obj.strongBuy, 0.10, 2.00);
    let buy       = clamp(obj.buy,       0.10, 2.50);
    let hold      = clamp(obj.hold,       0.10, 3.00);
    let expensive = clamp(obj.expensive,  0.10, 4.00);

    buy = Math.max(buy, strongBuy);
    hold = Math.max(hold, buy);
    expensive = Math.max(expensive, hold);

    return { strongBuy, buy, hold, expensive };
  }

  function onAnyChange(){
    const next = normalizeBands({
      strongBuy: nzNumInput(sb.value),
      buy:       nzNumInput(b.value),
      hold:      nzNumInput(h.value),
      expensive: nzNumInput(ex.value),
    });

    if([next.strongBuy,next.buy,next.hold,next.expensive].some(x => !Number.isFinite(x))) return;

    NUTZEN_STATE.buyBands = next;

    sb.value = String(next.strongBuy);
    b.value  = String(next.buy);
    h.value  = String(next.hold);
    ex.value = String(next.expensive);

    runAllCalcs();
  }

  // Listener (input = live)
  sb.addEventListener("input", onAnyChange);
  b.addEventListener("input",  onAnyChange);
  h.addEventListener("input",  onAnyChange);
  ex.addEventListener("input", onAnyChange);

  // Reset Button
  reset?.addEventListener("click", () => {
    syncInputsFromState();
    if(ovFair){
      ovFair.value = "";
      ovFair.dataset.auto = "1"; // zurück auf Auto
    }
    runAllCalcs();
  });
}






let NUTZEN_STATE = {
  sector: "standard",
  buyBands: { strongBuy:0.75, buy:0.90, hold:1.10, expensive:1.25 }
};



// ===== Presets in Prozent (nicht Dezimal) =====
const DCF_PRESETS = {
  eu:         { label:"EU",          rf: 3.00, erp: 5.00, gT: 2.00 },
  usa:        { label:"USA",         rf: 4.00, erp: 5.00, gT: 2.50 },
  middleeast: { label:"Middle East", rf: 5.00, erp: 6.50, gT: 2.50 },
  china:      { label:"China",       rf: 3.50, erp: 6.00, gT: 2.00 },
  defensive:  { label:"Defensiv",    rf: 4.00, erp: 6.00, gT: 1.50 },
  normal:     { label:"Normal",      rf: 3.50, erp: 5.50, gT: 2.00 },
  aggressive: { label:"Aggressiv",   rf: 3.00, erp: 4.50, gT: 3.00 },
};








// helper (dein nzNumInput kann Komma)
function readPctInput(id, fallbackPct){
  const elx = el(id);
  const n = nzNumInput(elx?.value);
  return Number.isFinite(n) ? n : fallbackPct; // Prozentzahl, z.B. 3.0
}

function writePctInput(id, pct){
  const elx = el(id);
  if(!elx) return;
  // DE Anzeige mit Komma
  elx.value = String(pct).replace(".", ",");
}



// Liefert Dezimalwerte zurück: 3% -> 0.03
function readDcfSettingsFromUI(){
  const presetSel = el("ovDcfPreset");
  const preset = presetSel?.value || "custom";

  // Defaults, falls Felder leer sind:
  const def = DCF_PRESETS.eu;

  const rfPct  = readPctInput("ovRf",  def.rf);
  const erpPct = readPctInput("ovErp", def.erp);
  const gTPct  = readPctInput("ovGt",  def.gT);

  const yEl = el("ovYears");
  let years = Number.isFinite(nzNumInput(yEl?.value)) ? Math.round(nzNumInput(yEl.value)) : 5;
  years = Math.max(1, Math.min(30, years));

  return {
    preset,
    rf:  rfPct  / 100,
    erp: erpPct / 100,
    gT:  gTPct  / 100,
    years
  };
}


function applyDcfPreset(key){
  const p = DCF_PRESETS?.[key];
  if(!p) return;

  const rfEl  = el("ovRf");
  const erpEl = el("ovErp");
  const gtEl  = el("ovGt");

  if(rfEl)  rfEl.value  = String(p.rf).replace(".", ",");
  if(erpEl) erpEl.value = String(p.erp).replace(".", ",");
  if(gtEl)  gtEl.value  = String(p.gT).replace(".", ",");
}


// ===== Listener einmalig binden =====
function wireDcfInputs(){
  if(wireDcfInputs._bound) return;

  const presetSel = el("ovDcfPreset");
  const rfEl  = el("ovRf");
  const erpEl = el("ovErp");
  const gtEl  = el("ovGt");
  const yEl   = el("ovYears");

  // Wenn die Elemente nicht existieren, quietly raus
  if(!presetSel || !rfEl || !erpEl || !gtEl || !yEl) {
    console.warn("DCF UI fehlt: prüfe IDs ovDcfPreset/ovRf/ovErp/ovGt/ovYears");
    return;
  }

  wireDcfInputs._bound = true;

  // Preset beim Laden anwenden (falls nicht custom)
  if(presetSel.value !== "custom") applyDcfPreset(presetSel.value);

  presetSel.addEventListener("change", () => {
    const val = presetSel.value;
    if(val !== "custom") applyDcfPreset(val);
    runAllCalcs();
  });

  // Wenn User manuell tippt -> preset auf custom setzen
  const onManual = () => {
    if(presetSel.value !== "custom") presetSel.value = "custom";
    runAllCalcs();
  };

  rfEl.addEventListener("input", onManual);
  erpEl.addEventListener("input", onManual);
  gtEl.addEventListener("input", onManual);
  yEl.addEventListener("input",  onManual);
}





/* ===========================
   1) Render: Sector Dropdown
=========================== */
function renderSectorSelect(){
  const sels = [el("nutzenHeaderSet"), el("nutzenHeaderSetTable")].filter(Boolean);
  if(sels.length === 0) return;

  for(const sel of sels){
    sel.innerHTML = "";
    for(const s of NUTZEN_SECTORS){
      const opt = document.createElement("option");
      opt.value = s.key;
      opt.textContent = s.label;
      if(s.key === NUTZEN_STATE.sector) opt.selected = true; // wie bei dir
      sel.appendChild(opt);
    }

    // Listener nur einmal binden (falls render mehrfach läuft)
    if(!sel.dataset.bound){
      sel.addEventListener("change", () => {
        // beide Selects synchron halten
        for(const other of sels) other.value = sel.value;

        setSector(sel.value);
        runAllCalcs();
      });
      sel.dataset.bound = "1";
    }
  }
}

/* ===========================
   2) Render: Year Dropdowns
=========================== */

function renderYearSelects(){
  const cfg = NUTZEN_YEARS_BY_SECTOR[NUTZEN_STATE.sector] || { cagr:[1,2,3,4], vol:[1,5,10] };

  const cagrSels = [el("nutzenCagrYear"), el("nutzenCagrYearTable")].filter(Boolean);
  const volSels  = [el("nutzenVolYear"),  el("nutzenVolYearTable")].filter(Boolean);

  // --- CAGR ---
  for(const cagrSel of cagrSels){
    const cur = Number(cagrSel.value) || 4;

    cagrSel.innerHTML = "";
    for(const y of cfg.cagr){
      const opt = document.createElement("option");
      opt.value = String(y);
      opt.textContent = `${y}Y`;
      cagrSel.appendChild(opt);
    }

    // keep if possible else default last
    cagrSel.value = cfg.cagr.includes(cur)
      ? String(cur)
      : String(cfg.cagr[cfg.cagr.length - 1] || 4);
  }

  // --- Vol ---
  for(const volSel of volSels){
    const cur = Number(volSel.value) || 1;

    volSel.innerHTML = "";
    for(const y of cfg.vol){
      const opt = document.createElement("option");
      opt.value = String(y);
      opt.textContent = `${y}Y`;
      volSel.appendChild(opt);
    }

    volSel.value = cfg.vol.includes(cur)
      ? String(cur)
      : String(cfg.vol[0] || 1);
  }
}


/* ===========================
   3) Render: Table from Headers
   - nimmt die Kriterien aus NUTZEN_HEADERS_BY_SECTOR[sector]
   - entfernt Duplikate
=========================== */
function uniq(arr){
  const seen = new Set();
  const out = [];
  for(const x of (arr || [])){
    const k = normKey(x);
    if(!k) continue;
    if(seen.has(k)) continue;
    seen.add(k);
    out.push(x);
  }
  return out;
}



function critLabel(id){
  return CRITERIA[id]?.label || `⚠️ ${id}`;
}



function renderNutzenTable(){
  console.log("✅ NEW renderNutzenTable() used", NUTZEN_STATE.sector);
  const tbody = el("nutzenTableBody");
  if(!tbody) return;

  // ✅ bestehende Werte sichern (damit Re-Render nichts löscht)
  const prev = tableToMap(); // Map: id -> text (z.B. "123", "–", ...)

  const idsRaw = NUTZEN_CRITERIA_BY_SECTOR[NUTZEN_STATE.sector] || [];
  const ids = uniq(idsRaw);

  tbody.innerHTML = "";
  for(const id of ids){
    const label = critLabel(id);
    const tr = document.createElement("tr");

    // ✅ alten Wert wieder einsetzen (wenn sinnvoll), sonst "–"
    const prevVal = prev?.get(id);
    const val = (prevVal !== undefined && String(prevVal).trim() !== "")
      ? prevVal
      : "–";

    tr.innerHTML = `
      <td class="muted" data-crit-id="${id}">${label}</td>
      <td data-crit-id="${id}" contenteditable="true" class="nutzenVal">${val}</td>
      <td class="muted"></td>
    `;
    tbody.appendChild(tr);

    if(!CRITERIA[id]) console.warn("CRITERIA fehlt für ID:", id, "Sector:", NUTZEN_STATE.sector);
  }
}



/* ===========================
   4) Render: Roles (simple list)
   Optional: später kannst du daraus Checkboxes machen
=========================== */
function renderRolesList(){
  const ul = el("nutzenRolesActive");
  if(!ul) return;
  ul.innerHTML = "";
  for(const r of NUTZEN_ROLES){
    const li = document.createElement("li");
    li.textContent = r;
    ul.appendChild(li);
  }

  // Overlay Rollen-Explain Platzhalter
  const rolesExplain = el("nutzenOverlayRolesExplain");
  if(rolesExplain){
    rolesExplain.textContent = "Rollen sind geladen. (Base/Health Why kommt aus deinen Role Rules.)";
  }
}

/* ===========================
   5) Paste Import -> Tabelle befüllen
   - nutzt deine parseExcelTSV Logik (Header|Value oder HeaderRow+ValueRow)
   - setzt Werte in die 2. Spalte anhand data-nutzen-key
=========================== */
function setTableValueByHeaderMap(valMap){
  const tbody = el("nutzenTableBody");
  if(!tbody) return;

  const rows = Array.from(tbody.querySelectorAll("tr"));
  let hits = 0;

  for(const tr of rows){
    const labelTd = tr.querySelector("td[data-crit-id]");
    const valTd   = tr.querySelector("td.nutzenVal");
    if(!labelTd || !valTd) continue;

    const id = labelTd.getAttribute("data-crit-id"); // <-- CRITERIA-ID
    if(!id) continue;

    // valMap kann Keys als ID ODER als normKey enthalten (Fallback)
    let v = undefined;

    if(valMap.has(id)) {
      v = valMap.get(id);
    } else {
      const labelText = (labelTd.textContent || "").trim();
      const k = normKey(labelText);
      if(valMap.has(k)) v = valMap.get(k);
    }

    if(v !== undefined){
      valTd.textContent = v;
      hits++;
    }
  }

  const pre = el("nutzenDebug");
  if(pre){
    pre.textContent = JSON.stringify({
      sector: NUTZEN_STATE.sector,
      mappedFields: valMap.size,
      updatedCells: hits
    }, null, 2);
  }
}


function parseValuesOnly(raw){
  const s = String(raw || "").replace(/\r/g, "").trim();
  if(!s) return [];

  // 1) Excel TSV (eine Zeile oder mehrere Zeilen mit Tabs)
  if(s.includes("\t")){
    return s
      .split(/\r?\n/)
      .flatMap(line => line.split("\t"))
      .map(x => x.trim())
      .filter(Boolean);
  }

  // 2) Zeilenweise (dein Beispiel)
  if(s.includes("\n")){
    return s
      .split("\n")
      .map(x => x.trim())
      .filter(Boolean);
  }

  // 3) Semikolon ist ok als Separator (DE)
  if(s.includes(";")){
    return s.split(";").map(x => x.trim()).filter(Boolean);
  }

  // 4) WICHTIG: NICHT an Komma splitten (Dezimaltrenner!)
  return [s];
}


function fillTableByOrder(values){
  const tbody = el("nutzenTableBody");
  if(!tbody) return;

  const rows = Array.from(tbody.querySelectorAll("tr"));
  let hits = 0;

  for(let i=0; i<rows.length; i++){
    const tr = rows[i];
    const labelTd = tr.querySelector("td[data-crit-id]");
    const valTd   = tr.querySelector("td.nutzenVal");
    if(!labelTd || !valTd) continue;

    const id = labelTd.getAttribute("data-crit-id");

    // ✅ Fair Value wird NICHT aus Paste befüllt
    if(id === "FAIR_VALUE") continue;

    const v = values[hits];        // <— wichtig: wir zählen nur “echte” Writes
    if(v === undefined) break;

    valTd.textContent = v;
    hits++;
  }

  const pre = el("nutzenDebug");
  if(pre){
    pre.textContent = JSON.stringify({
      mode: "values-only",
      pastedValues: values.length,
      tableRows: rows.length,
      writtenCells: hits,
      ignored: ["FAIR_VALUE"],
      leftoverValues: Math.max(0, values.length - hits)
    }, null, 2);
  }
}


function setTableValueById(id, text){
  const tbody = el("nutzenTableBody");
  if(!tbody) return false;

  const valTd = tbody.querySelector(`td.nutzenVal[data-crit-id="${id}"]`);
  if(!valTd) return false;

  // ✅ wenn User gerade in der Zelle tippt: nicht überschreiben
  if(document.activeElement === valTd) return false;

  valTd.textContent = (text ?? "–");
  return true;
}


function parseExcelTSV(input){
  const text = String(input || "").replace(/\r/g, "").trim();
  const map = new Map();
  if(!text) return map;

  const lines = text
    .split("\n")
    .map(l => l.trimEnd())
    .filter(l => l.trim().length);

  // ---- helper: header text -> stable criterion ID (fallback: normKey) ----
  function toCritKey(headerText){
    const id = (typeof critIdFromHeaderText === "function")
      ? critIdFromHeaderText(headerText)
      : null;
    return id || normKey(headerText);
  }

  // Helper: split a single line into [header, value] with common separators
  function splitLine(line){
    // 1) TSV
    if(line.includes("\t")){
      const parts = line.split("\t");
      if(parts.length >= 2) return [parts[0], parts.slice(1).join("\t")];
    }
    // 2) Header: Value
    const colonIdx = line.indexOf(":");
    if(colonIdx > 0) return [line.slice(0, colonIdx), line.slice(colonIdx + 1)];
    // 3) Header | Value
    if(line.includes("|")){
      const parts = line.split("|");
      if(parts.length >= 2) return [parts[0], parts.slice(1).join("|")];
    }
    // 4) Header ; Value
    if(line.includes(";")){
      const parts = line.split(";");
      if(parts.length >= 2) return [parts[0], parts.slice(1).join(";")];
    }
    return null;
  }

  // Format B (2 rows): header row + value row (TSV)
  const firstHasTab = lines[0]?.includes("\t");
  if(lines.length >= 2 && firstHasTab && lines[1].includes("\t")){
    const headers = lines[0].split("\t").map(x => x.trim());
    const values  = lines[1].split("\t").map(x => x.trim());
    for(let i=0;i<headers.length;i++){
      const h = headers[i];
      const v = values[i] ?? "";
      if(h && h.trim()) map.set(toCritKey(h), v);
    }
    return map;
  }

  // Format A: many lines, each line is header/value pair
  for(const line of lines){
    const hv = splitLine(line);
    if(!hv) continue;
    const h = (hv[0] || "").trim();
    const v = (hv[1] || "").trim();
    if(h) map.set(toCritKey(h), v);
  }

  // Fallback: ONE line like "Header\tValue\tHeader\tValue..."
  if(map.size === 0 && lines.length === 1 && lines[0].includes("\t")){
    const parts = lines[0].split("\t").map(x => x.trim());
    // interpret as pairs: H,V,H,V...
    for(let i=0;i<parts.length-1;i+=2){
      const h = parts[i];
      const v = parts[i+1];
      if(h) map.set(toCritKey(h), v ?? "");
    }
  }

  return map;
}






// ===== Helpers (deutsches/englisches Format) =====
function parseLocaleNumber(x){
  if(x == null) return NaN;
  const s = String(x).trim();
  if(!s) return NaN;

  const cleaned = s.replace(/[^\d.,-]/g, "");
  if(!cleaned) return NaN;

  // 1.234,56 -> 1234.56
  if(cleaned.includes(".") && cleaned.includes(",")){
    return Number(cleaned.replaceAll(".", "").replace(",", "."));
  }
  // 1234,56 -> 1234.56
  if(cleaned.includes(",") && !cleaned.includes(".")){
    return Number(cleaned.replace(",", "."));
  }
  // 1234.56
  return Number(cleaned);
}

function formatLocaleNumber(n){
  return (Math.round(n * 100) / 100).toFixed(2).replace(".", ",");
}



function tableToMap(){
  const tbody = document.getElementById("nutzenTableBody");
  const map = new Map();
  if(!tbody) return map;

  for(const tr of tbody.querySelectorAll("tr")){
    const labelTd = tr.querySelector("td[data-crit-id]");
    if(!labelTd) continue;

    const id = labelTd.getAttribute("data-crit-id");
    if(!id) continue;

    // 1) Dein Original: bevorzugt td.nutzenVal
    const valTd = tr.querySelector("td.nutzenVal");
    if(valTd){
      const v = (valTd.textContent || "").trim();
      map.set(id, v);
      continue;
    }

    // 2) Fallback: input/textarea in der Zeile
    const inp = tr.querySelector("input, textarea");
    if(inp){
      map.set(id, String(inp.value || "").trim());
      continue;
    }

    // 3) Fallback: letzte td (wenn keine nutzenVal-Klasse existiert)
    const tds = tr.querySelectorAll("td");
    if(tds.length){
      const v = (tds[tds.length - 1].textContent || "").trim();
      map.set(id, v);
      continue;
    }

    // 4) Notfall: setzen, aber leer
    map.set(id, "");
  }

  return map;
}





function syncFairValueFromTable(){
  const m = tableToMap?.();
  if(!m || typeof m.get !== "function") return;

  // ✅ hier kommt der Fair-Value aus deiner Tabelle (crit-id)
  const raw = m.get("FAIR_VALUE");
  const fv = parseLocaleNumber(raw);
  if(!Number.isFinite(fv) || fv <= 0) return;

  // Sidebar Input (dein Input heißt nutzenFairValue)
  const inp = el("nutzenFairValue");
  if(inp){
    const cur = parseLocaleNumber(inp.value);
    // nur automatisch überschreiben, wenn leer/ungültig
    if(!Number.isFinite(cur) || cur <= 0){
      inp.value = formatLocaleNumber(fv);
    }
  }

  // Optional: Overlay Override (ovFair) ebenfalls automatisch füllen
  const ov = el("ovFair");
  if(ov){
    const cur2 = parseLocaleNumber(ov.value);
    if(!Number.isFinite(cur2) || cur2 <= 0){
      ov.value = formatLocaleNumber(fv);
    }
  }
}








function renderOverlayBuyFromMap(m, fairOverride){
  const fairFromOverlay = nzNumInput(el("ovFair")?.value);
  const fairFromInput   = nzNum(el("nutzenFairValue")?.value);
  const fairFromTable   = nzNum(mGet(m, "FAIR_VALUE"));
  const priceNow        = nzNum(mGet(m, "PRICE_NOW"));

  const fair = Number.isFinite(fairOverride) ? fairOverride
             : Number.isFinite(fairFromOverlay) ? fairFromOverlay
             : Number.isFinite(fairFromInput)   ? fairFromInput
             : fairFromTable;

  const bands = computeBuyBandsFromFair(fair, NUTZEN_STATE.buyBands);

  const bEl = el("nutzenOverlayBuyExplain");
  if(bEl){
    const fmt = (n) => Number.isFinite(n) ? n.toLocaleString("de-DE",{maximumFractionDigits:2}) : "–";
    bEl.textContent = bands
      ? `Kurs: ${fmt(priceNow)} | Fair: ${fmt(fair)} | Strong Buy ≤ ${fmt(bands.strongBuyMax)} | Buy ≤ ${fmt(bands.buyMax)} | Hold ≤ ${fmt(bands.holdMax)} | Expensive > ${fmt(bands.expensiveMax)}`
      : `Kurs: ${fmt(priceNow)} | Fair: ${fmt(fair)} | Buy-Bands: –`;
  }

  const dEl = el("nutzenOverlayBuyDecision");
  if(dEl){
    const dec = computeBuyDecision(priceNow, fair, bands);
    dEl.innerHTML = `<span class="dot ${dec.mode}"></span> Aktion: ${dec.label}`;
  }

  return { fair, priceNow, bands };
}





function mGet(m, critId){
  return m.get(critId);
}



/* ===========================
   6) Sector setter (re-render alles)
=========================== */
function setSector(sectorKey){
  if(!NUTZEN_CRITERIA_BY_SECTOR?.[sectorKey]) sectorKey = "standard";
  NUTZEN_STATE.sector = sectorKey;

    // Warnungen, falls wichtige IDs im Sektor fehlen
  const ids = NUTZEN_CRITERIA_BY_SECTOR[NUTZEN_STATE.sector] || [];
  if(!ids.includes("FAIR_VALUE")) console.warn("Sector hat kein FAIR_VALUE:", NUTZEN_STATE.sector);
  if(!ids.includes("PRICE_NOW"))  console.warn("Sector hat kein PRICE_NOW:", NUTZEN_STATE.sector);

  renderYearSelects();
  renderNutzenTable();

  // optional: Debug
  const pre = el("nutzenDebug");
  if(pre){
    const ids = NUTZEN_CRITERIA_BY_SECTOR[NUTZEN_STATE.sector] || [];
    pre.textContent = JSON.stringify({
      sector: NUTZEN_STATE.sector,
      criteriaCount: ids.length,
      // optional: zeigt dir die IDs (hilft beim Prüfen)
      // criteriaIds: ids
    }, null, 2);
  }
}


/* ===========================
   7) Init
=========================== */
function initNutzenUI(){
  renderSectorSelect();
  renderYearSelects();
  renderNutzenTable();
  renderRolesList();

  // ✅ Listener (einmalig)
  wirePasteUI();
  wireSectorSelect();
  wireYearSelects();
  wireOverlayBuyInputs();

  wireDcfInputs();
  

  // optional initial
  runAllCalcs();
  wireTableAutoRecalc();
}

document.addEventListener("DOMContentLoaded", initNutzenUI);








    // Regeln für Rollen listener/leser



    function wireTableAutoRecalc(){
  const tbody = el("nutzenTableBody");
  if(!tbody) return;

  let t = null;
  function schedule(){
    clearTimeout(t);
    t = setTimeout(() => runAllCalcs(), 120); // debounce
  }

  tbody.addEventListener("input", (e) => {
    if(e.target && e.target.classList.contains("nutzenVal")){
      schedule();
    }
  });

  tbody.addEventListener("paste", (e) => {
    if(e.target && e.target.classList.contains("nutzenVal")){
      schedule();
    }
  });

  tbody.addEventListener("blur", (e) => {
    if(e.target && e.target.classList.contains("nutzenVal")){
      schedule();
    }
  }, true);
}





function nzBool(v){
  if(isMissing(v)) return null;
  const s = nzStr(v).toLowerCase();
  if(s === "ja" || s === "yes" || s === "true" || s === "1") return true;
  if(s === "nein" || s === "no" || s === "false" || s === "0") return false;
  return null; // unbekannt
}


function pct01Loose(v){
  const s = String(v ?? "").trim().replace(",", ".");
  if(!s) return NaN;

  // nimmt erste Zahl aus Strings wie "35% / 28% / 24%" oder "35 %"
  const m = s.match(/-?\d+(\.\d+)?/);
  if(!m) return NaN;

  const num = Number(m[0]);
  if(!Number.isFinite(num)) return NaN;

  return num > 1 ? num/100 : num; // 35 -> 0.35, 0.35 -> 0.35
}

function buildNutzenCtxFromTableMap(m){
  const ctx = {
    m,
    has: (x) => Number.isFinite(x) || x === true || x === false,
    chk: (label, ok, missing) => ({ label, ok: !!ok, missing: !!missing }),
  };

  ctx.num = (id) => nzNum(mGet(m, id));

  const PCT_LOOSE_IDS = new Set([
    "VOL_1_5_10",
    "DIV_YIELD",
    "FCF_YIELD_1Y",
    "FCF_MARGIN_1Y",
    "GROSS_MARGIN_1Y",
    "OP_MARGIN_1Y",
    "PROFIT_MARGIN_1Y",
    "ROIC_1Y",
    "ROE_1Y",
    "REV_GROWTH_YOY_1Y",
    "REV_CAGR_4Y",
    "EPS_GROWTH_CAGR_4Y",
    "DIVIDEND_DPS_CAGR_4Y",
    "SHARES_CHANGE_YOY",
    "PAYOUT_RATIO_1Y",
  ]);

  ctx.pct = (id) => {
    const raw = mGet(m, id);
    if(PCT_LOOSE_IDS.has(id)) return pct01Loose(raw);
    return nzPct01(raw);
  };

  ctx.boo = (id) => nzBool(mGet(m, id));
  ctx.str = (id) => nzStr(mGet(m, id));
  ctx.range = (id) => parseRangeLowHigh(mGet(m, id));

  return ctx;
}




const ROLE_RULES_BANKS      = {};
const ROLE_RULES_INSURANCE  = {};
const ROLE_RULES_REITS      = {};
const ROLE_RULES_UTILITIES  = {};
const ROLE_RULES_BROKERS    = {};
const ROLE_RULES_COMMODITIES= {};

const STRESS_RULES_BANKS      = () => STRESS_RULES_STANDARD;
const STRESS_RULES_INSURANCE  = () => STRESS_RULES_STANDARD;
const STRESS_RULES_REITS      = () => STRESS_RULES_STANDARD;
const STRESS_RULES_UTILITIES  = () => STRESS_RULES_STANDARD;
const STRESS_RULES_BROKERS    = () => STRESS_RULES_STANDARD;
const STRESS_RULES_COMMODITIES= () => STRESS_RULES_STANDARD;


   function pickRoleRulesBySector(sector){
  switch(sector){
    case "utilities":   return ROLE_RULES_UTILITIES;
    case "brokers":     return ROLE_RULES_BROKERS;
    case "commodities": return ROLE_RULES_COMMODITIES;
    case "banks":       return ROLE_RULES_BANKS;
    case "insurance":   return ROLE_RULES_INSURANCE;
    case "reits":       return ROLE_RULES_REITS;
    default:            return ROLE_RULES_STANDARD;
  }
}




function scoreChecks(checks){
  const arr = checks || [];
  const relevant = arr.filter(c => !c.missing);
  if(relevant.length === 0) return { pct: 0, ok: 0, total: 0 };
  const ok = relevant.filter(c => c.ok).length;
  return { pct: ok / relevant.length, ok, total: relevant.length };
}

function evalRolesForCurrentSector(){
  const m   = tableToMap();
  const ctx = buildNutzenCtxFromTableMap(m);

  const rules = pickRoleRulesBySector(NUTZEN_STATE.sector);
  const out = [];

  for(const role of NUTZEN_ROLES){
    const rr = rules?.[role];
    if(!rr) continue;

    const baseChecks   = rr.base   ? rr.base(ctx)   : [];
    const healthChecks = rr.health ? rr.health(ctx) : [];

    const baseScore   = scoreChecks(baseChecks);
    const healthScore = scoreChecks(healthChecks);

    const minPct = (typeof rr.minPct === "number") ? rr.minPct : 0.60;
    const active = baseScore.total > 0 && baseScore.pct >= minPct;

    out.push({ role, active, minPct, baseChecks, healthChecks, baseScore, healthScore });
  }

  out.sort((a,b) => (b.active - a.active) || (b.baseScore.pct - a.baseScore.pct));
  return out;
}



function renderRoleWhyBlocks(evRoles){
  const box = el("nutzenRoleWhyBase");     // wir nutzen nur Base-Box als “große Fläche”
  const healthBox = el("nutzenRoleWhyHealth"); // optional: wird nicht mehr gebraucht
  if(!box) return;

  // 👉 nur aktive Rollen (wenn du alle willst: const list = evRoles;)
  const list = (evRoles || []);

  const icon = (c) => c.ok ? "✅" : (c.missing ? "—" : "❌");
  const pct = (s) => Math.round(((s?.pct) || 0) * 100);

  function renderChecks(arr){
    const a = arr || [];
    if(a.length === 0) return `<div class="muted">–</div>`;
    return a.map(c => `<div class="whyLine">${icon(c)} ${c.label}</div>`).join("");
  }

  function renderRole(r){
    return `
      <div class="whyRoleBlock">
        <div class="whyRoleHead">
          <div class="whyRoleTitle">${r.active ? "✅" : "—"} ${r.role}</div>
          <div class="whyRoleMeta">
            Base ${pct(r.baseScore)}% (${r.baseScore.ok}/${r.baseScore.total}) ·
            Health ${pct(r.healthScore)}% (${r.healthScore.ok}/${r.healthScore.total})
          </div>
        </div>

        <div class="whyCols">
          <div class="whyCol">
            <div class="whyColTitle">Base</div>
            ${renderChecks(r.baseChecks)}
          </div>
          <div class="whyCol">
            <div class="whyColTitle">Health</div>
            ${renderChecks(r.healthChecks)}
          </div>
        </div>
      </div>
    `;
  }

  if(list.length === 0){
    box.innerHTML = `<div class="muted">Keine Rolle erfüllt (Base).</div>`;
  } else {
    box.innerHTML = list.map(renderRole).join("");
  }

  // healthBox wird nicht mehr benötigt (damit da nicht doppelt was steht)
  if(healthBox) healthBox.innerHTML = "";
}



function renderRolesFromEval(evRoles){
  // Liste rechts / irgendwo bei dir:

renderRoleWhyBlocks(evRoles);

  const ul = el("nutzenRolesActive");
  if(ul){
    ul.innerHTML = "";
    const act = evRoles.filter(r => r.active);
    if(act.length === 0){
      const li = document.createElement("li");
      li.textContent = "Keine Rolle erfüllt (Base).";
      ul.appendChild(li);
    } else {
      for(const r of act){
        const li = document.createElement("li");
        li.textContent = `${r.role} (${Math.round(r.baseScore.pct*100)}%)`;
        ul.appendChild(li);
      }
    }
  }

  // Overlay Explain (kurz)
  const explain = el("nutzenOverlayRolesExplain");
  if(explain){
   explain.textContent = `Rollen: ${summarizeRolesAll(evRoles)}`;
  }
}



function clamp(x, a, b){ return Math.max(a, Math.min(b, x)); }

function computeTargetFcfYield(ctx){
  // Basis in 0..1
  let y = 0.05; // 5% default

  const roic = ctx.pct("ROIC_1Y");
  const gm   = ctx.pct("GROSS_MARGIN_1Y");
  const beta = ctx.num("BETA");
  const nd   = ctx.num("NET_DEBT_EBITDA_1Y");
  const vol  = ctx.pct("VOL_1_5_10");

  // Quality -> niedrigere Zielrendite (höherer Fair Value)
  if(Number.isFinite(roic) && roic >= 0.12) y -= 0.005; // -0.5%
  if(Number.isFinite(gm) && gm >= 0.40)     y -= 0.005;

  // Risk -> höhere Zielrendite (niedrigerer Fair Value)
  if(Number.isFinite(beta) && beta >= 1.3)  y += 0.01;
  if(Number.isFinite(vol) && vol >= 0.45)   y += 0.01;
  if(Number.isFinite(nd) && nd >= 3.0)      y += 0.01;

  return clamp(y, 0.03, 0.12); // 3%..12%
}

function computeTargetPfcf(ctx){
  let t = 15; // default

  const roic = ctx.pct("ROIC_1Y");
  const growth = ctx.pct("REV_CAGR_4Y");
  const gm = ctx.pct("GROSS_MARGIN_1Y");
  const beta = ctx.num("BETA");

  // Growth/Quality
  if(Number.isFinite(roic) && roic >= 0.12) t += 5;
  if(Number.isFinite(gm) && gm >= 0.40)     t += 5;
  if(Number.isFinite(growth) && growth >= 0.10) t += 5;

  // Risk discount
  if(Number.isFinite(beta) && beta >= 1.3)  t -= 3;

  return clamp(t, 8, 35);
}

function median(arr){
  const a = (arr || []).filter(Number.isFinite).sort((x,y)=>x-y);
  if(a.length === 0) return NaN;
  const m = Math.floor(a.length/2);
  return a.length % 2 ? a[m] : (a[m-1] + a[m]) / 2;
}

function computeFairValueStandard(ctx){
  const price = ctx.num("PRICE_NOW");
  if(!Number.isFinite(price) || price <= 0) return NaN;

  const fairCandidates = [];

  // (1) via FCF Yield
  const fcfYield = ctx.pct("FCF_YIELD_1Y"); // 0..1
  if(Number.isFinite(fcfYield) && fcfYield > 0){
    const targetY = computeTargetFcfYield(ctx);
    const fairByYield = price * (fcfYield / targetY);
    if(Number.isFinite(fairByYield) && fairByYield > 0) fairCandidates.push(fairByYield);
  }

  // (2) via P/FCF
  const pfcf = ctx.num("P_FCF_1Y");
  if(Number.isFinite(pfcf) && pfcf > 0){
    const target = computeTargetPfcf(ctx);
    const fairByPfcf = price * (target / pfcf);
    if(Number.isFinite(fairByPfcf) && fairByPfcf > 0) fairCandidates.push(fairByPfcf);
  }

  // Fallback: wenn nix geht -> NaN
  return median(fairCandidates);
}




function runAllCalcs(){
  // ===== Rollen =====
  const roles = evalRolesForCurrentSector();
  renderRolesFromEval(roles);

  // ===== Fair Value erst berechnen + in Tabelle schreiben =====
  const m = tableToMap();
  const ctx = buildNutzenCtxFromTableMap(m);

  const fairFromTable   = nzNum(mGet(m, "FAIR_VALUE"));
  const fairFromInput   = nzNum(el("nutzenFairValue")?.value);
  const fairFromOverlay = nzNumInput(el("ovFair")?.value);

  const fairAuto = computeFairValueStandardDCF(ctx);

  const ov = el("ovFair");
  const overlayIsManual = !!(ov && ov.dataset.auto === "0");
  const manualOverlayHasValue = Number.isFinite(fairFromOverlay) && fairFromOverlay > 0;
  const manualInputHasValue   = Number.isFinite(fairFromInput) && fairFromInput > 0;
  const hasManualFair = (overlayIsManual && manualOverlayHasValue) || manualInputHasValue;

  // ✅ Auto-Fair in Tabelle schreiben, damit Stress ihn sieht
  if(Number.isFinite(fairAuto) && fairAuto > 0 && !hasManualFair){
    setTableValueById("FAIR_VALUE", fmtDE(fairAuto));
  }

  // Optional: ovFair auto befüllen (wie vorher)
  if(ov && document.activeElement !== ov){
    const isManual = (ov.dataset.auto === "0");
    if(!isManual && nzStr(ov.value).trim().length === 0 && Number.isFinite(fairAuto) && fairAuto > 0){
      ov.value = String(fairAuto).replace(".", ",");
      ov.dataset.auto = "1";
    }
  }

  // ✅ Map neu holen (jetzt ist FAIR_VALUE wirklich in der Tabelle)
  const m2 = tableToMap();

  // ===== Jetzt Stress (sieht FAIR_VALUE) =====
  const st = evalStressForCurrentSector();
  renderStress(st);
  const stressLabel = st?.label;

  // ===== Fair final (deine Priorität beibehalten) =====
  const fair2FromTable   = nzNum(mGet(m2, "FAIR_VALUE"));
  const fair = Number.isFinite(fairFromOverlay) ? fairFromOverlay
             : Number.isFinite(fairFromInput)   ? fairFromInput
             : Number.isFinite(fair2FromTable)  ? fair2FromTable
             : fairAuto;

  // ===== Buy / Overlay =====
  const bands = computeBuyBandsFromFair(fair, NUTZEN_STATE.buyBands);
  const buy = renderOverlayBuyFromMap(m2, fair);

  renderAktuellerZustand({ roles, st, buy });

  renderOverlaySummary({
    rolesText: summarizeRolesAll(roles),
    stressLabel,
    fair: buy?.fair,
    bands: buy?.bands
  });

  const pre = el("nutzenDebug");
  if(pre){
    pre.textContent = JSON.stringify({
      sector: NUTZEN_STATE.sector,
      fair,
      fairAuto,
      fairTableNow: fair2FromTable,
      stress: stressLabel
    }, null, 2);
  }
}








function wirePasteUI(){
  const btn = el("btnParseExcel");
  const clr = el("btnClearExcel");
  const ta  = el("excelPaste");
  if(!btn) return;

  btn.onclick = () => {
    const raw = ta?.value || "";
    if(!raw.trim()){
      alert("Bitte Werte einfügen.");
      return;
    }

    // 1) Versuch: Header/Value Mapping (funktioniert bei "Header\tValue" oder 2-Zeilen Header/Value)
    const m = parseExcelTSV(raw);

    // "Mapping lohnt sich", wenn mindestens 1 Key eine echte CRITERIA-ID ist
    const hasKnownCritId = m && m.size > 0 && [...m.keys()].some(k => !!CRITERIA?.[k]);

    if(hasKnownCritId){
      fillTableByMap(m);
    } else {
      // 2) Fallback: values-only nach Reihenfolge
      const values = parseValuesOnly(raw);
if(values.length === 0){
  alert("Keine Werte erkannt. Bitte Werte mit TAB (Excel), Zeilenumbrüchen, ; trennen.");
  return;
}

// ✅ Standard: nach deiner Excel-Master-Reihenfolge mappen
const mapped = buildMapFromValuesByOrder(values, PASTE_ORDER_STANDARD);
fillTableByMap(mapped);
    }

    runAllCalcs();
    openNutzenOverlay();
  };

  if(clr){
    clr.onclick = () => { if(ta) ta.value = ""; };
  }
}

function fillTableByMap(m){
  const tbody = document.getElementById("nutzenTableBody");
  if(!tbody) return;

  for(const tr of tbody.querySelectorAll("tr")){
    const idTd = tr.querySelector("td[data-crit-id]");
    if(!idTd) continue;

    const id = idTd.getAttribute("data-crit-id");
    if(!id || !m.has(id)) continue;

    const newVal = m.get(id);

    // 1) Dein Original: bevorzugt td.nutzenVal
    const valTd = tr.querySelector("td.nutzenVal");
    if(valTd){
      valTd.textContent = newVal;
      continue;
    }

    // 2) Fallback: input/textarea in der Zeile
    const inp = tr.querySelector("input, textarea");
    if(inp){
      inp.value = newVal;
      continue;
    }

    // 3) Fallback: letzte td (wenn keine nutzenVal-Klasse existiert)
    const tds = tr.querySelectorAll("td");
    if(tds.length){
      tds[tds.length - 1].textContent = newVal;
      continue;
    }

    // 4) Notfall: nichts zum Schreiben gefunden -> ignorieren
  }
}



function buildMapFromValuesByOrder(values, orderHeaders){
  const map = new Map();

  for(let i=0; i<orderHeaders.length; i++){
    const header = orderHeaders[i];
    const v = values[i];

    if(v === undefined) break;

    const id = (typeof critIdFromHeaderText === "function")
      ? critIdFromHeaderText(header)
      : null;

    const key = id || normKey(header);
    map.set(key, v);
  }

  return map;
}





function wireSectorSelect(){
  const sels = [el("nutzenHeaderSet"), el("nutzenHeaderSetTable")].filter(Boolean);
  if(sels.length === 0) return;

  // nur einmal binden
  if(wireSectorSelect._bound) return;
  wireSectorSelect._bound = true;

  for(const sel of sels){
    sel.addEventListener("change", () => {
      // beide Selects synchron halten
      for(const other of sels) other.value = sel.value;

      setSector(sel.value);
      runAllCalcs();
    });
  }
}


function wireYearSelects(){
  const cagrSels = [el("nutzenCagrYear"), el("nutzenCagrYearTable")].filter(Boolean);
  const volSels  = [el("nutzenVolYear"),  el("nutzenVolYearTable")].filter(Boolean);

  // nur einmal binden
  if(wireYearSelects._bound) return;
  wireYearSelects._bound = true;

  for(const sel of cagrSels){
    sel.addEventListener("change", () => {
      // beide synchron halten
      for(const other of cagrSels) other.value = sel.value;
      runAllCalcs();
    });
  }

  for(const sel of volSels){
    sel.addEventListener("change", () => {
      // beide synchron halten
      for(const other of volSels) other.value = sel.value;
      runAllCalcs();
    });
  }
}




    // Regeln für Rollen/ Standard 

    // ==============================
// ROLE_RULES_STANDARD (für deine neuen Standard Kriterien)
// - nutzt ctx.num / ctx.pct / ctx.boo
// - pct = 0..1 (weil nzPct01)
// ==============================
const ROLE_RULES_STANDARD = (() => {
  const isFin = Number.isFinite;
  const abs = Math.abs;

  const N = (ctx, id) => ctx.num(id);
  const P = (ctx, id) => ctx.pct(id);
  const B = (ctx, id) => ctx.boo(id);

  function chkNum(ctx, label, id, pred){
    const v = N(ctx,id);
    const missing = !isFin(v);
    return ctx.chk(label, !missing && !!pred(v), missing);
  }
  function chkPct(ctx, label, id, pred){
    const v = P(ctx,id);
    const missing = !isFin(v);
    return ctx.chk(label, !missing && !!pred(v), missing);
  }
  function chkBool(ctx, label, id, pred){
    const v = B(ctx,id);
    const missing = (v !== true && v !== false);
    return ctx.chk(label, !missing && !!pred(v), missing);
  }

  // ===== helpers =====
  function priceToFair(ctx){
    const price = N(ctx,"PRICE_NOW");
    const fair  = N(ctx,"FAIR_VALUE");
    if(!isFin(price) || !isFin(fair) || fair <= 0) return NaN;
    return price / fair; // <1 günstig
  }

  function capBucket(ctx){
    const mc = N(ctx,"MARKET_CAP");
    if(!isFin(mc) || mc <= 0) return null;
    if(mc < 2e9) return "small";
    if(mc < 1e10) return "mid";
    if(mc < 2e11) return "large";
    return "mega";
  }

  // ===== Dilution Helpers =====

// Shares Change (YoY) ist der Kern.
// Shares Outstanding nutzen wir als Plausi/Skalierung, damit Microcaps nicht “zufällig” verrutschen.
function dilutionHealth(ctx){
  const chg = P(ctx, "SHARES_CHANGE_YOY");         // 0..1
  const so  = N(ctx, "SHARES_OUT_DILUTED_1Y");     // absolute shares (z.B. 15.2B)
  const missing = !isFin(chg) || !isFin(so) || so <= 0;

  if(missing){
    return ctx.chk("Dilution: Shares Change (YoY) + Shares Outstanding verfügbar", false, true);
  }

  // wir bewerten nur anhand Shares Change:
  // <= 0% (Buybacks/flat) gut
  // 0..2% ok
  // 2..5% Warnsignal
  // >5% klar negativ
  const ok = chg <= 0.02; // bis +2% noch “ok”
  return ctx.chk(
    `Dilution (YoY) ≤ +2% (aktuell: ${(chg*100).toFixed(2)}%)`,
    ok,
    false
  );
}


function payoutSafeIfDividend(ctx, max=1.00){
  const y = P(ctx,"DIV_YIELD");
  const p = P(ctx,"PAYOUT_RATIO_1Y");
  const missing = !Number.isFinite(y) || !Number.isFinite(p);
  if(missing) return ctx.chk("Payout Ratio (nur falls Dividende)", false, true);
  if(y <= 0) return ctx.chk("Payout Ratio (keine Dividende → neutral)", true, false);
  return ctx.chk(`Payout Ratio ≤ ${(max*100).toFixed(0)}%`, p <= max, false);
}

function dilutionBad(ctx){
  const chg = P(ctx, "SHARES_CHANGE_YOY");
  const so  = N(ctx, "SHARES_OUT_DILUTED_1Y");
  const missing = !isFin(chg) || !isFin(so) || so <= 0;

  if(missing) return ctx.chk("Starke Verwässerung (YoY) ≤ +5% (Warnung wenn >5%)", false, true);

  // ✅ ok wenn <=5%, ❌ wenn >5%
  return ctx.chk(
    `Starke Verwässerung (YoY) ≤ +5% (aktuell: ${(chg*100).toFixed(2)}%)`,
    chg <= 0.05,
    false
  );
}

// ===== Payout Safety Helpers =====
function payoutSafe(ctx, max=0.80){
  // Payout Ratio als pct (0..1). Wenn dein Input manchmal "130%" ist -> pct = 1.30
  return chkPct(ctx, `Payout Ratio ≤ ${(max*100).toFixed(0)}%`, "PAYOUT_RATIO_1Y", p => p > 0 && p <= max);
}

function payoutDanger(ctx){
  // ✅ ok wenn <=100%, ❌ wenn >100%
  return chkPct(ctx, "Payout Ratio ≤ 100% (Warnung wenn >100%)", "PAYOUT_RATIO_1Y", p => p <= 1.00);
}

  // Liquidity “Puffer”: Cash / Debt
  function cashToDebt(ctx){
    const cash = N(ctx,"CASH_STI_1Y");
    const debt = N(ctx,"TOTAL_DEBT_1Y");
    if(!isFin(cash) || !isFin(debt) || debt <= 0) return NaN;
    return cash / debt;
  }

  // Dilution Proxy (negativ ist gut)
  // Shares Change (YoY): + = Verwässerung, - = Rückkauf
  // (pct: 0..1)
  function sharesDilution(ctx){
    const s = P(ctx,"SHARES_CHANGE_YOY");
    return isFin(s) ? s : NaN;
  }

  // ===== shared “Quality Core” =====
  function qualityCoreBase(ctx){
    return [
      chkPct(ctx, "ROIC ≥ 10%", "ROIC_1Y", x => x >= 0.10),
      chkPct(ctx, "Gross Margin ≥ 35%", "GROSS_MARGIN_1Y", x => x >= 0.35),
      chkPct(ctx, "Operating Margin ≥ 10%", "OP_MARGIN_1Y", x => x >= 0.10),
      chkBool(ctx, "FCF positiv", "FCF_POSITIVE_YN", x => x === true),
      chkPct(ctx, "FCF-Marge ≥ 5%", "FCF_MARGIN_1Y", x => x >= 0.05),
    ];
  }

  function balanceSheetStrongBase(ctx){
    return [
      chkNum(ctx, "Net Debt/EBITDA ≤ 2.5", "NET_DEBT_EBITDA_1Y", x => x <= 2.5),
      chkNum(ctx, "Zinsdeckung ≥ 5", "INTEREST_COVERAGE_1Y", x => x >= 5),
      chkNum(ctx, "Current Ratio ≥ 1.2", "CURRENT_RATIO_1Y", x => x >= 1.2),
      // Cash-Puffer (optional, aber sehr nützlich)
      ctx.chk("Cash/Total Debt ≥ 0.25", (() => {
        const r = cashToDebt(ctx);
        return isFin(r) ? r >= 0.25 : false;
      })(), !isFin(cashToDebt(ctx))),
    ];
  }

  function leveragedBase(ctx){
    return [
      chkNum(ctx, "Net Debt/EBITDA ≥ 3.5", "NET_DEBT_EBITDA_1Y", x => x >= 3.5),
      chkNum(ctx, "Zinsdeckung < 3", "INTEREST_COVERAGE_1Y", x => x < 3),
      chkNum(ctx, "Current Ratio < 1.0", "CURRENT_RATIO_1Y", x => x < 1.0),
    ];
  }

  return {
    // =========================
    // Dividende
    // =========================
    "Dividenden Aristokrat": {
      minPct: 0.60,
      base: (ctx) => [
        chkNum(ctx, "Dividend Growth years ≥ 10", "DIV_GROWTH_YEARS", y => y >= 10),
        chkPct(ctx, "Div.-Rendite ≥ 2%", "DIV_YIELD", y => y >= 0.02),
        chkPct(ctx, "DPS CAGR 4Y ≥ 3%", "DIVIDEND_DPS_CAGR_4Y", g => g >= 0.03),
        chkPct(ctx, "Payout Ratio ≤ 70%", "PAYOUT_RATIO_1Y", p => p <= 0.70),
      ],
health: (ctx) => [
  chkBool(ctx, "FCF positiv (Deckung)", "FCF_POSITIVE_YN", x => x === true),
  payoutSafe(ctx, 0.80),          // strenger bei Aristokrat
  payoutDanger(ctx),              // zeigt explizit, ob >100% (wird ❌ wenn true)
  dilutionHealth(ctx),            // Buybacks/low dilution ist gut
  chkNum(ctx, "Net Debt/EBITDA ≤ 3.0", "NET_DEBT_EBITDA_1Y", x => x <= 3.0),
  chkNum(ctx, "Zinsdeckung ≥ 4", "INTEREST_COVERAGE_1Y", x => x >= 4),
],
      
    },

    "Dividendenwachstum": {
      minPct: 0.60,
      base: (ctx) => [
        chkNum(ctx, "Dividend Growth years ≥ 5", "DIV_GROWTH_YEARS", y => y >= 5),
        chkPct(ctx, "DPS CAGR 4Y ≥ 7%", "DIVIDEND_DPS_CAGR_4Y", g => g >= 0.07),
        chkPct(ctx, "Payout 20–70%", "PAYOUT_RATIO_1Y", p => p >= 0.20 && p <= 0.70),
        chkBool(ctx, "FCF positiv", "FCF_POSITIVE_YN", x => x === true),
      ],
      health: (ctx) => [
        chkPct(ctx, "FCF-Marge ≥ 5%", "FCF_MARGIN_1Y", x => x >= 0.05),
        chkNum(ctx, "Net Debt/EBITDA ≤ 3.0", "NET_DEBT_EBITDA_1Y", x => x <= 3.0),
        payoutSafe(ctx, 0.90),
payoutDanger(ctx),
dilutionHealth(ctx),
      ],
    },

    // =========================
    // Value / Growth / GARP
    // =========================
    "Value": {
      minPct: 0.60,
      base: (ctx) => [
        // Preis vs Fair
        ctx.chk("Preis ≤ Fairer Preis", (() => {
          const r = priceToFair(ctx);
          return isFin(r) ? r <= 1.0 : false;
        })(), !isFin(priceToFair(ctx))),

        chkNum(ctx, "KGV ≤ 15", "PE_1Y", x => x > 0 && x <= 15),
        chkNum(ctx, "EV/EBITDA ≤ 10", "EV_EBITDA_1Y", x => x > 0 && x <= 10),
        chkNum(ctx, "P/FCF ≤ 15", "P_FCF_1Y", x => x > 0 && x <= 15),
        chkPct(ctx, "FCF Yield ≥ 5%", "FCF_YIELD_1Y", y => y >= 0.05),
      ],
health: (ctx) => [
  chkBool(ctx, "FCF positiv", "FCF_POSITIVE_YN", x => x === true),
  chkNum(ctx, "Net Debt/EBITDA ≤ 3.0", "NET_DEBT_EBITDA_1Y", x => x <= 3.0),
  payoutSafeIfDividend(ctx, 1.00),
],
    },

    "Wachstum": {
      minPct: 0.60,
      base: (ctx) => [
        chkPct(ctx, "Revenue Growth YoY ≥ 10%", "REV_GROWTH_YOY_1Y", x => x >= 0.10),
        chkPct(ctx, "Revenue CAGR 4Y ≥ 10%", "REV_CAGR_4Y", x => x >= 0.10),
        chkPct(ctx, "EPS CAGR 4Y ≥ 12%", "EPS_GROWTH_CAGR_4Y", x => x >= 0.12),
        chkPct(ctx, "Operating Margin ≥ 10%", "OP_MARGIN_1Y", x => x >= 0.10),
      ],
      health: (ctx) => [
        chkBool(ctx, "FCF positiv", "FCF_POSITIVE_YN", x => x === true),
        chkPct(ctx, "FCF-Marge ≥ 5%", "FCF_MARGIN_1Y", x => x >= 0.05),
      ],
    },

    "GARP": {
      minPct: 0.60,
      base: (ctx) => [
        chkPct(ctx, "EPS CAGR 4Y ≥ 10%", "EPS_GROWTH_CAGR_4Y", x => x >= 0.10),
        chkPct(ctx, "Revenue CAGR 4Y ≥ 8%", "REV_CAGR_4Y", x => x >= 0.08),
        chkNum(ctx, "KGV ≤ 25", "PE_1Y", x => x > 0 && x <= 25),
        chkNum(ctx, "EV/EBITDA ≤ 18", "EV_EBITDA_1Y", x => x > 0 && x <= 18),
        chkPct(ctx, "ROIC ≥ 10%", "ROIC_1Y", x => x >= 0.10),
      ],
      health: (ctx) => [
        chkBool(ctx, "FCF positiv", "FCF_POSITIVE_YN", x => x === true),
        chkPct(ctx, "FCF-Marge ≥ 5%", "FCF_MARGIN_1Y", x => x >= 0.05),
      ],
    },

    // =========================
    // Quality / Pricing Power / Defensive
    // =========================
    "Quality": {
      minPct: 0.60,
      base: (ctx) => qualityCoreBase(ctx),
      health: (ctx) => [
        ...balanceSheetStrongBase(ctx),
        chkPct(ctx, "Profit Margin ≥ 8%", "PROFIT_MARGIN_1Y", x => x >= 0.08),
        chkPct(ctx, "ROE ≥ 12%", "ROE_1Y", x => x >= 0.12),
      ],
    },

    "Pricing Power": {
      minPct: 0.60,
      base: (ctx) => [
        chkPct(ctx, "Gross Margin ≥ 40%", "GROSS_MARGIN_1Y", x => x >= 0.40),
        chkPct(ctx, "Operating Margin ≥ 15%", "OP_MARGIN_1Y", x => x >= 0.15),
        chkPct(ctx, "ROIC ≥ 12%", "ROIC_1Y", x => x >= 0.12),
        chkBool(ctx, "FCF positiv", "FCF_POSITIVE_YN", x => x === true),
      ],
      health: (ctx) => [
        chkPct(ctx, "FCF-Marge ≥ 8%", "FCF_MARGIN_1Y", x => x >= 0.08),
        chkNum(ctx, "Net Debt/EBITDA ≤ 2.5", "NET_DEBT_EBITDA_1Y", x => x <= 2.5),
      ],
    },

    "Defensiv": {
      minPct: 0.60,
      base: (ctx) => [
        chkNum(ctx, "Beta ≤ 1.0", "BETA", x => x <= 1.0),
        chkPct(ctx, "Volatilität (Proxy) ≤ 40%", "VOL_1_5_10", x => x <= 0.40),
        chkPct(ctx, "Profit Margin ≥ 6%", "PROFIT_MARGIN_1Y", x => x >= 0.06),
        chkBool(ctx, "FCF positiv", "FCF_POSITIVE_YN", x => x === true),
        chkPct(ctx, "Div.-Rendite ≥ 1.5%", "DIV_YIELD", x => x >= 0.015),
      ],
health: (ctx) => [
  chkNum(ctx, "Net Debt/EBITDA ≤ 3.0", "NET_DEBT_EBITDA_1Y", x => x <= 3.0),
  chkNum(ctx, "Zinsdeckung ≥ 4", "INTEREST_COVERAGE_1Y", x => x >= 4),
  payoutSafe(ctx, 0.95),     // ✅ neu (nicht zu streng)
  dilutionHealth(ctx),       // ✅ neu
],
    },

    "stabil Defensiv": {
      minPct: 0.60,
      base: (ctx) => [
        chkNum(ctx, "Beta ≤ 0.9", "BETA", x => x <= 0.9),
        chkPct(ctx, "Volatilität (Proxy) ≤ 35%", "VOL_1_5_10", x => x <= 0.35),
        chkPct(ctx, "ROIC ≥ 10%", "ROIC_1Y", x => x >= 0.10),
        chkBool(ctx, "FCF positiv", "FCF_POSITIVE_YN", x => x === true),
        chkPct(ctx, "FCF-Marge ≥ 8%", "FCF_MARGIN_1Y", x => x >= 0.08),
      ],
health: (ctx) => [
  ...balanceSheetStrongBase(ctx),
  payoutSafe(ctx, 0.90),     // ✅ neu (etwas strenger)
  dilutionHealth(ctx),       // ✅ neu
],
    },

    "Gesund": {
  minPct: 0.60,

  // Base = “gesundes Fundament”
  base: (ctx) => [
    chkBool(ctx, "FCF positiv", "FCF_POSITIVE_YN", x => x === true),
    chkPct(ctx, "FCF-Marge ≥ 5%", "FCF_MARGIN_1Y", x => x >= 0.05),
    chkPct(ctx, "Profit Margin ≥ 6%", "PROFIT_MARGIN_1Y", x => x >= 0.06),
    chkPct(ctx, "ROIC ≥ 10%", "ROIC_1Y", x => x >= 0.10),
    chkNum(ctx, "Current Ratio ≥ 1.2", "CURRENT_RATIO_1Y", x => x >= 1.2),
  ],

  // Health = “Risiko-Puffer / Bilanzstress”
  health: (ctx) => [
    chkNum(ctx, "Net Debt/EBITDA ≤ 3.0", "NET_DEBT_EBITDA_1Y", x => x <= 3.0),
    chkNum(ctx, "Zinsdeckung ≥ 4", "INTEREST_COVERAGE_1Y", x => x >= 4),
    dilutionHealth(ctx), // Shares YoY ≤ +2% (dein Helper)
    ctx.chk("Cash/Total Debt ≥ 0.25", (() => {
      const cash = ctx.num("CASH_STI_1Y");
      const debt = ctx.num("TOTAL_DEBT_1Y");
      if(!Number.isFinite(cash) || !Number.isFinite(debt) || debt <= 0) return false;
      return (cash / debt) >= 0.25;
    })(), (() => {
      const cash = ctx.num("CASH_STI_1Y");
      const debt = ctx.num("TOTAL_DEBT_1Y");
      return !(Number.isFinite(cash) && Number.isFinite(debt) && debt > 0);
    })()),
  ],
},


    // =========================
    // Balance Sheet Tags
    // =========================
    "Balance Sheet Strong": {
      minPct: 0.60,
      base: (ctx) => balanceSheetStrongBase(ctx),
health: (ctx) => [
  chkBool(ctx, "FCF positiv (Puffer)", "FCF_POSITIVE_YN", x => x === true),
  payoutSafe(ctx, 0.95),     // ✅ neu
  dilutionHealth(ctx),       // ✅ neu
],
   
    },

    "Schuldenlastig/ Leveraged": {
      minPct: 0.60,
      base: (ctx) => leveragedBase(ctx),
      health: (ctx) => [
        chkBool(ctx, "FCF nicht positiv", "FCF_POSITIVE_YN", x => x === false),
        ctx.chk("Cash/Total Debt < 0.10", (() => {
          const r = cashToDebt(ctx);
          return isFin(r) ? r < 0.10 : false;
        })(), !isFin(cashToDebt(ctx))),
      ],
    },

    // =========================
    // Turnaround / Spec / Crisis / Cyclical
    // =========================
    "Turnaround": {
      minPct: 0.60,
      base: (ctx) => [
        chkPct(ctx, "Revenue Growth > 0", "REV_GROWTH_YOY_1Y", x => x > 0),
        chkPct(ctx, "Profit Margin > 0", "PROFIT_MARGIN_1Y", x => x > 0),
        chkBool(ctx, "FCF positiv", "FCF_POSITIVE_YN", x => x === true),
        chkPct(ctx, "EPS CAGR 4Y > 0", "EPS_GROWTH_CAGR_4Y", x => x > 0),
      ],
      health: (ctx) => [
        chkNum(ctx, "Net Debt/EBITDA < 5.0", "NET_DEBT_EBITDA_1Y", x => x < 5.0),
        chkNum(ctx, "Zinsdeckung ≥ 2", "INTEREST_COVERAGE_1Y", x => x >= 2),
      ],
    },

"Zykliker": {
  minPct: 0.60,
  base: (ctx) => [
    chkNum(ctx, "Beta ≥ 1.2", "BETA", x => x >= 1.2),
    chkPct(ctx, "Volatilität hoch (Proxy ≥ 45%)", "VOL_1_5_10", x => x >= 0.45),
    chkPct(ctx, "Revenue YoY |≥15%| (Proxy)", "REV_GROWTH_YOY_1Y", x => abs(x) >= 0.15),

    // ✅ neu: "nicht defensiv" statt OP Margin <15
    chkPct(ctx, "Nicht defensiv (Profit Margin < 8%)", "PROFIT_MARGIN_1Y", x => x < 0.08),
  ],
  health: (ctx) => [
    chkNum(ctx, "Net Debt/EBITDA ≤ 3.5", "NET_DEBT_EBITDA_1Y", x => x <= 3.5),
    chkBool(ctx, "FCF positiv", "FCF_POSITIVE_YN", x => x === true),
  ],
},

    "Spekulation": {
      minPct: 0.60,
      base: (ctx) => [
        chkNum(ctx, "KGV sehr hoch (≥ 40) oder negativ", "PE_1Y", x => x >= 40 || x <= 0),
        chkNum(ctx, "P/FCF sehr hoch (≥ 35) oder negativ", "P_FCF_1Y", x => x >= 35 || x <= 0),
        chkPct(ctx, "Volatilität extrem (≥ 60%)", "VOL_1_5_10", x => x >= 0.60),
        chkPct(ctx, "Profit Margin ≤ 0%", "PROFIT_MARGIN_1Y", x => x <= 0),
      ],
      health: (ctx) => [
        chkBool(ctx, "FCF nicht positiv", "FCF_POSITIVE_YN", x => x === false),
        chkNum(ctx, "Net Debt/EBITDA ≥ 3.5", "NET_DEBT_EBITDA_1Y", x => x >= 3.5),
        chkNum(ctx, "Zinsdeckung < 3", "INTEREST_COVERAGE_1Y", x => x < 3),
      ],
    },

    "Krisenfall": {
      minPct: 0.60,
      base: (ctx) => [
        chkBool(ctx, "FCF nicht positiv", "FCF_POSITIVE_YN", x => x === false),
        chkPct(ctx, "Profit Margin ≤ 0%", "PROFIT_MARGIN_1Y", x => x <= 0),
        chkNum(ctx, "Zinsdeckung < 2", "INTEREST_COVERAGE_1Y", x => x < 2),
        chkNum(ctx, "Current Ratio < 1.0", "CURRENT_RATIO_1Y", x => x < 1.0),
      ],
health: (ctx) => [
  chkNum(ctx, "Net Debt/EBITDA ≥ 4.0", "NET_DEBT_EBITDA_1Y", x => x >= 4.0),
  chkPct(ctx, "Revenue Growth negativ", "REV_GROWTH_YOY_1Y", x => x < 0),
  payoutDanger(ctx),         // ✅ neu
  dilutionBad(ctx),          // ✅ neu (wenn starke Verwässerung)
],
    },

    // =========================
    // Recurring Revenue (Proxy!)
    // =========================
    "Abo Modell/ Recurring Revenue": {
      minPct: 0.60,
      base: (ctx) => [
        chkPct(ctx, "Gross Margin ≥ 60% (Proxy)", "GROSS_MARGIN_1Y", x => x >= 0.60),
        chkPct(ctx, "ROIC ≥ 10%", "ROIC_1Y", x => x >= 0.10),
        chkPct(ctx, "Revenue CAGR 4Y ≥ 10%", "REV_CAGR_4Y", x => x >= 0.10),
        chkPct(ctx, "FCF-Marge ≥ 5%", "FCF_MARGIN_1Y", x => x >= 0.05),
      ],
      health: (ctx) => [
        chkBool(ctx, "FCF positiv", "FCF_POSITIVE_YN", x => x === true),
      ],
    },

    // =========================
    // Size Roles
    // =========================
    "Small Cap": {
      minPct: 1.0,
      base: (ctx) => [
        ctx.chk("Market Cap < $2B", capBucket(ctx) === "small", capBucket(ctx) === null),
      ],
      health: (ctx) => [
        chkPct(ctx, "Volatilität ≤ 60% (Proxy)", "VOL_1_5_10", x => x <= 0.60),
      ],
    },

    "Mid Cap": {
      minPct: 1.0,
      base: (ctx) => [
        ctx.chk("$2B ≤ Market Cap < $10B", capBucket(ctx) === "mid", capBucket(ctx) === null),
      ],
      health: (ctx) => [],
    },

    "Large Cap": {
      minPct: 1.0,
      base: (ctx) => [
        ctx.chk("$10B ≤ Market Cap < $200B", capBucket(ctx) === "large", capBucket(ctx) === null),
      ],
      health: (ctx) => [],
    },

    "Mega Cap": {
      minPct: 1.0,
      base: (ctx) => [
        ctx.chk("Market Cap ≥ $200B", capBucket(ctx) === "mega", capBucket(ctx) === null),
      ],
      health: (ctx) => [],
    },
  };
  
})();






       // Regeln für Rollen Banks

  
           // Regeln für Rollen Versicherer 
        
  



               // Regeln für Rollen REITs
 



                   // Regeln für Rollen Versorger
   


                         // Regeln für Rollen Broker



                            // Regeln für Rollen Rohstoffe 






    // Regeln für Stress Flag





    function pickStressEvalShape(stressEval){
  // Du kannst hier später “deine echte Struktur” sauber einsetzen.
  // Unterstützt mehrere mögliche Keys:
  const baseTriggers =
    stressEval?.baseTriggers ||
    stressEval?.base ||
    stressEval?.baseFlags ||
    stressEval?.triggersBase ||
    [];

  const healthTriggers =
    stressEval?.healthTriggers ||
    stressEval?.health ||
    stressEval?.healthFlags ||
    stressEval?.triggersHealth ||
    [];

  const color =
    stressEval?.color ||
    stressEval?.stressColor ||
    stressEval?.level ||
    null;

  const label =
    stressEval?.label ||
    stressEval?.stressLabel ||
    null;

  return {
    baseTriggers: normalizeTriggers(baseTriggers),
    healthTriggers: normalizeTriggers(healthTriggers),
    color,
    label
  };
}

function escapeHtml(str){
  return String(str ?? "")
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;")
    .replaceAll("'","&#039;");
}





// Farbe aus Base+Health ableiten (konservativ, aber stabil)
function stressColorFromCounts(baseC, healthC){
  const totalRelevant = (baseC.total || 0) + (healthC.total || 0);
  if(totalRelevant === 0) return null;

  const warn = (baseC.warnBad || 0) + (healthC.warnBad || 0);
  const crit = (baseC.critBad || 0) + (healthC.critBad || 0);

  // Dunkelrot = echte Krise (viele kritische)
  if(crit >= 4) return "darkbad";

  // Rot = Krise (mind. 2 kritische) oder 1 kritische + viele Warnsignale
  if(crit >= 2 || (crit >= 1 && warn >= 3)) return "bad";

  // Gelb = Warnsignale
  if(warn >= 1) return "warn";

  // Grün
  return "good";
}

function stressLabel(mode){
  if(mode === "good") return "Grün";
  if(mode === "warn") return "Gelb";
  if(mode === "bad") return "Rot";
  if(mode === "darkbad") return "Dunkelrot";
  return "–"; // ✅ null/unknown
}

// Helper für Trigger
function t(label, bad, missing){
  return { label, bad: !!bad, missing: !!missing };
}




function pickStressRulesBySector(sector){
  switch(sector){
    case "utilities":   return STRESS_RULES_UTILITIES;
    case "brokers":     return STRESS_RULES_BROKERS;
    case "commodities": return STRESS_RULES_COMMODITIES;
    case "banks":       return STRESS_RULES_BANKS;
    case "insurance":   return STRESS_RULES_INSURANCE;
    case "reits":       return STRESS_RULES_REITS;
    default:            return STRESS_RULES_STANDARD;
  }
}

function evalStressForCurrentSector(){
  const m   = tableToMap();
  const ctx = buildNutzenCtxFromTableMap(m);

  const rules = pickStressRulesBySector(NUTZEN_STATE.sector) || STRESS_RULES_STANDARD;

  const baseTriggers   = (rules.base   ? rules.base(ctx)   : []) || [];
  const healthTriggers = (rules.health ? rules.health(ctx) : []) || [];

  const baseC   = countBySev(baseTriggers);
  const healthC = countBySev(healthTriggers);

  const mode  = stressColorFromCounts(baseC, healthC); // good/warn/bad/darkbad
  const label = stressLabel(mode);

  return {
    mode,
    label,
    baseTriggers,
    healthTriggers,
    score: { base: baseC, health: healthC }
  };
}




function stressLegendHTML(st){
  const b = st?.score?.base   || { warnBad:0, critBad:0, total:0 };
  const h = st?.score?.health || { warnBad:0, critBad:0, total:0 };

  const baseWarn   = b.warnBad || 0;
  const baseCrit   = b.critBad || 0;
  const healthWarn = h.warnBad || 0;
  const healthCrit = h.critBad || 0;

  const warn = baseWarn + healthWarn;
  const crit = baseCrit + healthCrit;

  // exakt wie stressColorFromCounts()
  const isDarkRed = (crit >= 4);
  const isRed     = !isDarkRed && (crit >= 2 || (crit >= 1 && warn >= 3));
  const isYellow  = !isDarkRed && !isRed && (warn >= 1);
  const isGreen   = !isDarkRed && !isRed && !isYellow;

  const icon = (ok, missing=false) => missing ? "—" : (ok ? "✅" : "❌");
  const line = (ok, label, missing=false) => `<div class="whyLine">${icon(ok, missing)} ${label}</div>`;

  const renderTriggerList = (arr) => {
    const a = arr || [];
    if(a.length === 0) return `<div class="muted">–</div>`;
    return a.map(tg => {
      const ic = tg.missing ? "—" : (tg.bad ? "❌" : "✅");
      return `<div class="whyLine">${ic} ${tg.label}</div>`;
    }).join("");
  };

  function block(title, dotClass, active, baseLinesHTML, healthLinesHTML){
    return `
      <div class="whyRoleBlock">
        <div class="whyRoleHead">
          <div class="whyRoleTitle">
            <span class="dot ${dotClass}" style="display:inline-block;margin-right:8px;vertical-align:middle"></span>
            ${active ? "✅" : "—"} ${title}
          </div>
          <div class="whyRoleMeta">
            Base warn ${baseWarn} · krit ${baseCrit} · Health warn ${healthWarn} · krit ${healthCrit}
          </div>
        </div>

        <div class="whyCols">
          <div>
            <div class="whyColTitle">Base</div>
            ${baseLinesHTML}

            <div class="whyColTitle" style="margin-top:10px">Trigger (Base)</div>
            ${renderTriggerList(st?.baseTriggers)}
          </div>

          <div>
            <div class="whyColTitle">Health</div>
            ${healthLinesHTML}

            <div class="whyColTitle" style="margin-top:10px">Trigger (Health)</div>
            ${renderTriggerList(st?.healthTriggers)}
          </div>
        </div>
      </div>
    `;
  }

  // Regeln-Linien (Severity-basiert)
  const greenBase   = line(baseWarn + baseCrit === 0,   `0 Trigger bad (aktuell: ${baseWarn+baseCrit})`);
  const greenHealth = line(healthWarn + healthCrit === 0, `0 Trigger bad (aktuell: ${healthWarn+healthCrit})`);

  const yellowBase  = line(warn >= 1, `Warnsignale ≥ 1 (aktuell: ${warn})`);
  const yellowHealth = line(crit === 0, `keine Krise-Trigger (kritisch: ${crit})`);

  const redBase = line(crit >= 2 || (crit >= 1 && warn >= 3), `Krise (kritisch: ${crit}, warn: ${warn})`);
  const redHealth = line(!isDarkRed, `nicht Dunkelrot`);

  const darkRedBase = line(crit >= 4, `Echte Krise (kritisch ≥ 4)`);
  const darkRedHealth = line(crit >= 4, `kritisch: ${crit}`);

  return [
    block("Grün",      "good",    isGreen,    greenBase,    greenHealth),
    block("Gelb",      "warn",    isYellow,   yellowBase,   yellowHealth),
    block("Rot",       "bad",     isRed,      redBase,      redHealth),
    block("Dunkelrot", "darkbad", isDarkRed,  darkRedBase,  darkRedHealth),
  ].join("");
}




function renderStressWhyNow(st){
  const host = el("stressWhyNow");
  if(!host) return;

  if(!st){
    host.innerHTML = `<div class="muted">–</div>`;
    return;
  }

  const icon = (x) => x?.missing ? "—" : (x?.bad ? "❌" : "✅");
  const esc = (s) => String(s ?? "")
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;")
    .replaceAll("'","&#039;");

  const renderList = (arr) => (arr || []).map(tr =>
    `<div class="trigLine">${icon(tr)} ${esc(tr.label)}</div>`
  ).join("") || `<div class="muted">–</div>`;

const b = st?.score?.base   || { warnBad:0, critBad:0, total:0 };
const h = st?.score?.health || { warnBad:0, critBad:0, total:0 };

  const mode  = st?.mode  || "";     // "good" | "warn" | "bad" | "darkbad"
  const label = st?.label || "–";    // "Grün" | "Gelb" | ...

  host.innerHTML = `
    <div class="whyNowBlock">
      <div class="whyNowHead">
        <div class="whyNowLeft">
          <span class="dot ${mode}"></span>
          <div class="whyNowTitle">${esc(label)}</div>
        </div>
        <div class="whyNowMeta">Hover → Trigger-Details</div>
      </div>

      <div class="whyNowMeta" style="margin-top:6px">
        Base: warn ${b.warnBad||0} · krit ${b.critBad||0} (total ${b.total||0})
· Health: warn ${h.warnBad||0} · krit ${h.critBad||0} (total ${h.total||0})

      </div>

      <div class="whyNowBody">
        <div class="whyCols">
          <div class="whyCol">
            <div class="whyColTitle">Base Trigger</div>
            ${renderList(st?.baseTriggers)}
          </div>
          <div class="whyCol">
            <div class="whyColTitle">Health Trigger</div>
            ${renderList(st?.healthTriggers)}
          </div>
        </div>
      </div>
    </div>
  `;
}


function renderStressPageClean(st){
  // Dot + Label
  const dot = el("stressPageDot");
  if(dot){
    dot.classList.remove("good","warn","bad","darkbad");
    if(st?.mode) dot.classList.add(st.mode);
  }
  const lab = el("stressPageLabel");
  if(lab) lab.textContent = `Stress: ${st?.label ?? "–"}`;

  // Warum jetzt?
  renderStressWhyNow(st);

  // Farben Erklärung (immer alle Farben)
const legend = el("stressLegendAll");
if(legend) legend.innerHTML = stressLegendHoverHTML(); // immer gleich, ohne st
}





function stressLegendHoverHTML(){
  const rows = [
    { mode:"good",    name:"Grün",      hint:"Hover → Details",
      base:["✅ 0 negative Trigger"],
      health:["✅ 0 negative Trigger"],
      combo:["→ nicht Gelb/Rot/Dunkelrot"]
    },
    { mode:"warn",    name:"Gelb",      hint:"Hover → Details",
      base:["❌ ≥ 1 negativer Trigger"],
      health:["❌ ≥ 1 negativer Trigger"],
      combo:["✅ nicht Rot/Dunkelrot"]
    },
    { mode:"bad",     name:"Rot",       hint:"Hover → Details",
      base:["❌ ≥ 3 negative Trigger","❌ Kombi: Base ≥ 2 & Health ≥ 1"],
      health:["❌ ≥ 3 negative Trigger"],
      combo:["✅ nicht Dunkelrot"]
    },
    { mode:"darkbad", name:"Dunkelrot", hint:"Hover → Details",
      base:["❌ ≥ 4 negative Trigger","❌ Kombi: Base ≥ 3 & Health ≥ 2"],
      health:["❌ ≥ 4 negative Trigger"],
      combo:["→ höchste Warnstufe"]
    }
  ];

  const line = (t, muted=false) => `<div class="whyLine ${muted ? "muted":""}">${t}</div>`;

  return rows.map(r => `
    <div class="whyStressBlock">
      <div class="whyStressHead">
        <div class="whyStressTitle">
          <span class="dot ${r.mode}"></span>
          <span>${r.name}</span>
        </div>
        <div class="whyStressHint muted">${r.hint}</div>
      </div>

      <div class="whyStressBody">
        <div class="whyCols">
          <div>
            <div class="whyColTitle">Base</div>
            ${(r.base||[]).map(x => line(x)).join("")}
          </div>
          <div>
            <div class="whyColTitle">Health</div>
            ${(r.health||[]).map(x => line(x)).join("")}
          </div>
        </div>
        <div style="margin-top:8px">
          ${(r.combo||[]).map(x => line(x,true)).join("")}
        </div>
      </div>
    </div>
  `).join("");
}




function renderStress(st){
  // Stress Seite (falls vorhanden)
  renderStressPageClean?.(st);

  // Chip / Label (Home/Overlay)
  setDot(el("dotStress"), st?.mode);
  const t = el("txtStress");
  if(t) t.textContent = `Stress: ${st?.label ?? "–"}`;

  // Detail-Explain: welche Trigger erfüllt/nicht erfüllt
  const box = el("stressExplain");
  if(box){
    const icon = (x) => x.missing ? "—" : (x.bad ? "❌" : "✅");
    const renderList = (arr) => (arr || []).map(tr =>
      `<div class="whyLine">${icon(tr)} ${tr.label}</div>`
    ).join("") || `<div class="muted">–</div>`;

    const b = st?.score?.base   || { bad:0, total:0 };
    const h = st?.score?.health || { bad:0, total:0 };

    box.innerHTML = `
      <div class="whyRoleBlock">
        <div class="whyRoleHead">
          <div class="whyRoleTitle">Stress-Details</div>
          <div class="whyRoleMeta">
            Base: ${b.bad}/${b.total} neg · Health: ${h.bad}/${h.total} neg
          </div>
        </div>
        <div class="whyCols">
          <div class="whyCol">
            <div class="whyColTitle">Base</div>
            ${renderList(st?.baseTriggers)}
          </div>
          <div class="whyCol">
            <div class="whyColTitle">Health</div>
            ${renderList(st?.healthTriggers)}
          </div>
        </div>
      </div>
    `;
  }

  // Overlay Kurztext
  const ov = el("nutzenOverlayStressExplain");
  if(ov){
    const b = st?.score?.base   || { bad:0, total:0 };
    const h = st?.score?.health || { bad:0, total:0 };
    ov.textContent =
  `Stress: ${st?.label ?? "–"} | Base warn ${b.warnBad||0}/krit ${b.critBad||0} | Health warn ${h.warnBad||0}/krit ${h.critBad||0}`;
  }
}

function chkPctBad(ctx, label, id, isBad){
  const v = P(ctx,id);
  const missing = !Number.isFinite(v);
  // ok ist TRUE, wenn NICHT bad
  return ctx.chk(label, !missing && !isBad(v), missing);
}

function chkNumBad(ctx, label, id, isBad){
  const v = N(ctx,id);
  const missing = !Number.isFinite(v);
  return ctx.chk(label, !missing && !isBad(v), missing);
}





    // Regeln für Stress Flag/ Standard 


const STRESS_RULES_STANDARD = {
  label: "Standard",

  base: (ctx) => {
    const trigs = [];
const pushNum = (label, id, predBad, sev="warn") => {
  const v = ctx.num(id);
  const missing = !Number.isFinite(v);
  trigs.push({ label, bad: !missing && !!predBad(v), missing, sev });
};
const pushPct = (label, id, predBad, sev="warn") => {
  const v = ctx.pct(id);
  const missing = !Number.isFinite(v);
  trigs.push({ label, bad: !missing && !!predBad(v), missing, sev });
};
const pushBool = (label, id, predBad, sev="warn") => {
  const v = ctx.boo(id);
  const missing = (v !== true && v !== false);
  trigs.push({ label, bad: !missing && !!predBad(v), missing, sev });
};

    // --- Preis vs Fair (nur 1 Trigger) ---
    const price = ctx.num("PRICE_NOW");
    const fair  = ctx.num("FAIR_VALUE");
    const pfOk = Number.isFinite(price) && Number.isFinite(fair) && fair > 0;
    const pf = pfOk ? (price / fair) : NaN;

trigs.push({
  label: "Preis stark über Fair Value (≥ +40%)",
  bad: pfOk ? (pf >= 1.40) : false,
  missing: !pfOk,
  sev: "warn"
});

    // --- Multiples (nicht zu aggressiv) ---
    pushNum("KGV sehr hoch (≥ 45) oder negativ", "PE_1Y", x => x >= 45 || x <= 0);
    pushNum("EV/EBITDA hoch (≥ 30) oder negativ", "EV_EBITDA_1Y", x => x >= 30 || x <= 0);
    pushNum("P/FCF sehr hoch (≥ 40) oder negativ", "P_FCF_1Y", x => x >= 40 || x <= 0);

    // --- Risiko (nur extreme Werte) ---
    pushNum("Beta extrem (≥ 1.7)", "BETA", x => x >= 1.7);
    pushPct("Volatilität extrem (≥ 65%)", "VOL_1_5_10", x => x >= 0.65);

    // --- Dilution ---
    pushPct("Starke Verwässerung (Shares YoY ≥ +5%)", "SHARES_CHANGE_YOY", x => x >= 0.05);

    // --- Dividend Yield extrem hoch (mögliche Falle) ---
    pushPct("Div.-Rendite extrem (≥ 10%)", "DIV_YIELD", x => x >= 0.10);

    return trigs;
  },
health: (ctx) => {
  const trigs = [];

  const pushNum = (label, id, predBad, sev="warn") => {
    const v = ctx.num(id);
    const missing = !Number.isFinite(v);
    trigs.push({ label, bad: !missing && !!predBad(v), missing, sev });
  };
  const pushPct = (label, id, predBad, sev="warn") => {
    const v = ctx.pct(id);
    const missing = !Number.isFinite(v);
    trigs.push({ label, bad: !missing && !!predBad(v), missing, sev });
  };
  const pushBool = (label, id, predBad, sev="warn") => {
    const v = ctx.boo(id);
    const missing = (v !== true && v !== false);
    trigs.push({ label, bad: !missing && !!predBad(v), missing, sev });
  };

  // --- Cashflow / Profitability (Krise = critical) ---
  pushBool("FCF nicht positiv", "FCF_POSITIVE_YN", x => x === false, "critical");

  pushPct("FCF-Marge negativ (< 0%)", "FCF_MARGIN_1Y", x => x < 0, "critical");
  pushPct("FCF-Marge sehr schwach (< 2%)", "FCF_MARGIN_1Y", x => x < 0.02, "warn");

  pushPct("Operating Margin negativ", "OP_MARGIN_1Y", x => x < 0, "critical");
  pushPct("Profit Margin negativ", "PROFIT_MARGIN_1Y", x => x < 0, "critical");
  pushNum("Net Income negativ", "NET_INCOME_1Y", x => x < 0, "critical");

  // --- Growth / Trend (Krise = critical) ---
  pushPct("Revenue Growth negativ (YoY 1Y)", "REV_GROWTH_YOY_1Y", x => x < 0, "critical");
  pushPct("Revenue CAGR 4Y deutlich negativ (< -2%)", "REV_CAGR_4Y", x => x < -0.02, "critical");

  // Optional: EPS negativ (Warnung oder Krise – ich setze warn)
  pushNum("EPS (Diluted) ≤ 0", "EPS_DILUTED", x => x <= 0, "warn");

  // --- Leverage / Coverage / Liquidity (Krise = critical) ---
  pushNum("Net Debt/EBITDA hoch (≥ 4.0)", "NET_DEBT_EBITDA_1Y", x => x >= 4.0, "critical");
  pushNum("Zinsdeckung kritisch (< 2)", "INTEREST_COVERAGE_1Y", x => x < 2, "critical");
  pushNum("Current Ratio schwach (< 1.0)", "CURRENT_RATIO_1Y", x => x < 1.0, "critical");

  // --- Cash vs Debt Puffer (Krise = critical) ---
  const cash = ctx.num("CASH_STI_1Y");
  const debt = ctx.num("TOTAL_DEBT_1Y");
  const cdOk = Number.isFinite(cash) && Number.isFinite(debt) && debt > 0;
  const cd = cdOk ? (cash / debt) : NaN;

  trigs.push({
    label: "Cash/Total Debt sehr niedrig (< 0.05)",
    bad: cdOk ? (cd < 0.05) : false,
    missing: !cdOk,
    sev: "critical"
  });

  // --- Gesund (Financial Health) als GELB-Warnsignal (max. 1 Trigger) ---
  (() => {
    const soft = 0
      + ((Number.isFinite(ctx.pct("ROIC_1Y")) && ctx.pct("ROIC_1Y") < 0.08) ? 1 : 0)
      + ((Number.isFinite(ctx.pct("PROFIT_MARGIN_1Y")) && ctx.pct("PROFIT_MARGIN_1Y") < 0.04) ? 1 : 0)
      + ((Number.isFinite(ctx.num("NET_DEBT_EBITDA_1Y")) && ctx.num("NET_DEBT_EBITDA_1Y") >= 3.0) ? 1 : 0)
      + ((Number.isFinite(ctx.num("INTEREST_COVERAGE_1Y")) && ctx.num("INTEREST_COVERAGE_1Y") < 4) ? 1 : 0)
      + ((Number.isFinite(ctx.num("CURRENT_RATIO_1Y")) && ctx.num("CURRENT_RATIO_1Y") < 1.2) ? 1 : 0)
      + ((Number.isFinite(ctx.pct("SHARES_CHANGE_YOY")) && ctx.pct("SHARES_CHANGE_YOY") >= 0.02) ? 1 : 0);

    trigs.push({
      label: "Gesundheit: mehrere Warnsignale (Soft-Checks ≥ 2)",
      bad: soft >= 2,
      missing: false,
      sev: "warn"
    });
  })();

  // --- Dividend Safety GATING ---
  const dy = ctx.pct("DIV_YIELD");
  const dgy = ctx.num("DIV_GROWTH_YEARS");
  const isDividendCase =
    (Number.isFinite(dy) && dy >= 0.02) ||
    (Number.isFinite(dgy) && dgy > 0);

  const payout = ctx.pct("PAYOUT_RATIO_1Y");
  const payoutMissing = !Number.isFinite(payout);

  trigs.push({
    label: "Payout > 100% (nur relevant bei Dividend-Case)",
    bad: (!payoutMissing && isDividendCase) ? (payout > 1.00) : false,
    missing: payoutMissing || !isDividendCase,
    sev: "warn"
  });

  trigs.push({
    label: "Payout > 130% (kritisch, nur Dividend-Case)",
    bad: (!payoutMissing && isDividendCase) ? (payout > 1.30) : false,
    missing: payoutMissing || !isDividendCase,
    sev: "critical"
  });

  return trigs;
}
};
   








        // Regeln für Stress Flag/ Banks

  
            // Regeln für Stress Flag/ Versicherer 
        
  



                // Regeln für Stress Flag/ REITs
 



                    // Regeln für Stress Flag/ Versorger
   


                        // Regeln für Stress Flag/ Broker



                            // Regeln für Stress Flag/ Rohstoffe 

                



console.log("JS loaded");


(function debugPageSwitch(){
  const pTable = document.getElementById("page-table");
  const pHome  = document.getElementById("page-home");

  if(!pTable || !pHome) return;

  // Beobachte Class-Änderungen
  const obs = new MutationObserver(() => {
    const tableOn = pTable.classList.contains("isActive");
    const homeOn  = pHome.classList.contains("isActive");
    if(tableOn && !homeOn){
      console.log("⚠️ Tabelle wurde aktiv geschaltet!");
      console.trace("Stacktrace (wer war’s):");
    }
  });

  obs.observe(pTable, { attributes:true, attributeFilter:["class"] });
})();






console.log("SCRIPT END");
  </script>
</body>
</html>
